===================================
How to handle Exceptions in JAVA
===================================
-> Exception means unexpected and un-wanted situation which distrubs normal flow of our program execution
-> To continue program execution we need to handle exceptions occured in the program
-> To handle exceptions occured in the program we have below 5 keywords in java

1) try
2) catch
3) finally
4) throw
5) throws
-> try block is used to keep error-prone code

try {

	// code
}

Note: try block should contain either catch block or finally block
-> catch block is used to write the logic to catch the exception (exception handling logic)

		try {
			// logic
		} catch (Exception e ){
			// handling logic
		}

Note: try is mandatory to write catch block. One try block can have multiple catch blocks also

-> finally block is used to execute clean up logic. Always finally block will be executed irrespective of exception.

try {
		// logic
} catch (Exception e) {
		// handling logic
} finally {
	// clean up
}

-> try with catch ---> valid
-> try with finally ---> valid
-> try - catch - finally ---> valid
-> try without catch or finally ---> invalid
-> try with multiple catch blocks ---> valid


-> throws keyword is used to handover checked exceptions to caller method. The exceptions which identified at compilation time are called as Checked Exceptions.

public class Demo {
	
	public static void main(String[ ] args) throws FileNotFoundException {
		FileReader fr = new FileReader(new File("abc.txt"));
	}
}

-> throw keyword is used to create the Exception

package in.ashokit;

public class Demo {

	public static void main(String[] args) throws Exception {

		throw new Exception("Not Possible");
	}
}

Note: In Java 1.7 try with resources concept introduced. 
When we open any resource in try block that resource will be auto closed when try block execution got completed.


============================================================================
Java Program to read data from File  using try without resources (upto 1.6v)
============================================================================

package in.ashokit;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class Demo {

	public static void main(String[] args) {

		FileReader fr = null;
		try {
			fr = new FileReader(new File("abc.txt"));
			int read = fr.read();
			System.out.println(read);
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			if (fr != null)
				try {
					fr.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
		}
	}
}


===================================================================================
Java Program to read data from File  using try with resources(introduced in java 7)
===================================================================================
package in.ashokit;

import java.io.File;
import java.io.FileReader;

public class Demo {

	public static void main(String[] args) {

		try (FileReader fr = new FileReader(new File("abc.txt"))) {
			int read = fr.read();
			System.out.println(read);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

=====================
Multiple Catch Blocks
========================
-> For single try block we can write multiple catch blocks
=> When we are writing multiple catch blocks, the hierarchy should be child to parent.

// invalid code because second catch block is un-reachable  //parent should be in last catch block
try{
	int a = 10 / 0;
} catch (Exception e) {
	s.o.p("catch-1");
} catch (ArithematicException e) {
	s.o.p("catch-2");
}


// valid code
try{
	int a = 10 / 0;
} catch (ArithematicException e) {
	s.o.p("catch-1");
} catch (Exception e) {
	s.o.p("catch-2");
}

=> We can handle multiple Exceptions in Single Catch block also like below

public class Test {

	public static void main(String[] args) {
		try {
			int a = 10 / 0;
} catch (ArithmaticException | Exception e) {
			System.out.println("Catch-1");
		}


public class Test {

	public static void main(String[] args) {
		try {
			int a = 10 / 0;
			File f = new File("abc.txt");
			FileReader fr = new FileReader(f);
			DriverManager.getConnection("url", "uname", "pwd");
		} catch (IOException | SQLException e) {
			System.out.println("Catch-1");
		}
	}
}

=======================
User Defined Exceptions
=======================
-> In Java already there are so many Predefined Exceptions available
   Ex: NullPointerException, ArithematicException, ClassCastException, SQLException etc....
-> If required we can create Our Own Exception also in Java that is called as User-Defined Exception
-> To create User Defined Exception, we have to extend the properties from either Exception class Or RuntimeException class

package in.ashokit;
public class NoDataFoundException extends Exception {

	public NoDataFoundException() {

	}

	public NoDataFoundException(String msg) {
		super(msg);
	}
}


package com.exception.demo;
public class Demo {

	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		
		Demo d=new Demo();
		
		d.getData(101);

	}
	
	public void getData(Integer id) throws Exception{
		
		if(id<=100) {
			
			System.out.println("getting data from DB");
		}else {
			
			throw new NoDataFoundException("Invalid ID");
		}
		
		
	}

}

====================
Exceptions Hierarchy
====================
-> Throwable is super class for all the Exceptions
-> Exceptions are divided into 2 types

		1) Exception
		2) Error

-> Exceptions can be handled where as error can't be handled

============================
Spring Boot - Exception Handling
============================
1) Controller Based Exception Handling  (specific to one controller)
->This approach involves defining exception handlers within a controller class using the @ExceptionHandler annotation. 
->These handlers would only handle exceptions thrown within that specific controller.

2) Global Exception Handling (Entire Project) ---- Recommended
->This approach, considered the recommended practice, uses a @RestControllerAdvice annotated class to define global exception handlers. 
->These handlers can handle exceptions thrown from any controller or service in the application.


------------------------------UserDefinedException-----------------------------
package in.ashokit.exception;

public class NoProductFoundException extends RuntimeException {

	public NoProductFoundException() {
		// TODO Auto-generated constructor stub
	}

	public NoProductFoundException(String msg) {
		super(msg);
	}
}

------------------------------------------------------------------------
package in.ashokit.exception;

import lombok.Data;

@Data
public class ExceptionBean {
	
	private String code;
	private String msg;

}
----------------------------------------------------------------
@RestController
public class ProductRestController {

	@Autowired
	private ProductService service;

	@GetMapping("/product/{pid}")
	public String getProduct(@PathVariable Integer pid) {
		
		return service.getProductName(pid);

	}	
}
------------------------------------------------------------------------------
@Service
public class ProductService {

	public String getProductName(Integer pid) {

		if (pid == 100) {
			return "Mouse";
		} else if (pid == 101) {
			return "Keyboard";
		} else {
			throw new NoProductFoundException("Invalid Product ID");
		}
	}
}

---------------------------Exception Handler-----------------------------------
@RestControllerAdvice
public class AppExceptionHandler {

	@ExceptionHandler(value = NoProductFoundException.class)
	public ResponseEntity<ExceptionBean> handleNoDataFoundException(NoProductFoundException ne) {

		String message = ne.getMessage();

		ExceptionBean eb = new ExceptionBean();
		
		eb.setCode("ERRXX8080");
		eb.setMsg(message);

		return new ResponseEntity<ExceptionBean>(eb, HttpStatus.BAD_REQUEST);

	}

	@ExceptionHandler(value = NullPointerException.class)
	public ResponseEntity<ExceptionBean> handleNPE(NullPointerException ne) {

		String message = ne.getMessage();

		ExceptionBean eb = new ExceptionBean();
		eb.setCode("ERRXX8081");
		eb.setMsg(ne.toString());

		return new ResponseEntity<ExceptionBean>(eb, HttpStatus.INTERNAL_SERVER_ERROR);

	}

}
----------------------------------------------
@RestController
public class DemoRestController {
	
	@GetMapping("/demo")
	public String getMsg() {
		String s = null;
		s.length();
		return "hi";
	}
}
-------------------------------------------------
==================
EXPLANATION
=================
->When you call /product/102 (invalid ID), the ProductService throws a NoProductFoundException.
->The AppExceptionHandler catches this exception and creates a ResponseEntity with a custom error code ("ERRXX8080") and the message "Invalid Product ID".
->This response is sent back to the client with a HttpStatus.BAD_REQUEST status code, indicating an error on the client side (invalid ID).
->Similarly, if a NullPointerException occurs in DemoRestController:
->The handleNPE method in AppExceptionHandler would be invoked and return a response with a custom error code and potentially more details about the NullPointerException

======================================
Benefits of Global Exception Handling:
========================================
->Centralized Management: You can handle exceptions in one place, making your code more organized and easier to maintain.
->Consistent Error Responses: You can provide consistent error messages and formats throughout your application.
->Improved User Experience: You can provide more meaningful error information to clients.



