INDEX
======

What is JVM (Java Virtual Machine)?
JVM Memory Model (Memory Structure of JVM)
Where to Configure JVM Memory Settings?
Difference Between JDK, JRE, and JVM in Java
Why is String Immutable in Java?
CompletableFuture............vimp 
Spring WebFlux?
AppDynamics
Disadvantafes of using Rest API
COSUMER & BICONSUMER............vimp
Function & BiFunction............vimp
Predicate............vimp
Function & Predicate............vimp
Diff between Spring, Spring MCV & SB
SPRINGBOOT
What is Reactive Programming in Spring Boot?
What is High Concurrency?
As u have used hibernate  how to deal with multiple databases how you are going to configure it
Comparable & Comparator
StringBuffer & StringBuilder
What is @Conditional in Spring Boot?
What is a JIT Compiler?
Difference between Hashmap & Hashtable
What is Marker interface & Functional Interface............vimp
What are indexes.Clustered & Non clustered indexes
What is JWT.What it consist
What is an Abstract Class in Java?............vimp
Abstract Class vs Interface in Java............vimp
Interface & Functional Interface............vimp
peek() method in stream API
Use of @Primary & @Qualifier annotations
How to reduce our Sprinboot startup time 
What happens when springboot application starts
Process of creating spring boot project
Create One Springboot Project to call Rest API
========================================
What is JVM (Java Virtual Machine)?
=======================================
->JVM (Java Virtual Machine) is a runtime environment that executes Java bytecode.
-> It is responsible for converting compiled .class files (bytecode) into machine code that the operating system can understand

VM provides features like:
✅ Memory Management (Garbage Collection)
✅ Platform Independence (Write Once, Run Anywhere)
✅ Security & Performance Optimization
===============
JVM Components
================
JVM consists of:
ClassLoader – Loads bytecode (.class files) into memory.
Runtime Memory (JVM Memory Model) – Stores classes, objects, methods, and execution stacks.
Execution Engine – Converts bytecode into machine code and executes it.
Native Interface – Connects JVM with OS-specific native libraries.


===========================================
 JVM Memory Model (Memory Structure of JVM)
===========================================
JVM memory is divided into five main areas:

->Method Area (Metadata Storage)
 Stores class metadata, static variables, and method code.

->It contains:
Class Definitions
Static Variables
Method Code (including static methods)
Runtime Constant Pool (String Pool, Constants, etc.) 📌 Shared across all threads.

->Heap Memory (Object Storage)
 Stores all objects and instance variables.
 Managed by the Garbage Collector (GC).
Heap is divided into:
Young Generation (Short-lived objects, divided into Eden & Survivor spaces)
Old Generation (Tenured) (Long-lived objects)
Metaspace (Stores class metadata, replaces PermGen in Java 8+) 📌 Shared across all threads.

->Stack Memory (Thread Execution Storage)
 Stores local variables and method calls of each thread.
 Every thread has its own stack, which contains:

Method Frames (each method call has a frame)
Local Variables
Operand Stack (Intermediate Calculation Data)
Return Address 📌 Thread-specific (not shared).

->Program Counter (PC Register)
Holds the memory address of the current executing instruction in a thread.
Each thread has its own PC Register.

->Native Method Stack
Stores native method information when JVM interacts with OS-level code (e.g., JNI calls).
 Thread-specific (not shared).

================================
JVM Memory Allocation and Size
==================================
The maximum memory allocated depends on system RAM and JVM configuration.
Default memory sizes in Java:

->Heap Memory (Dynamic)

-Xms (Initial Heap Size) → 512MB (default)
-Xmx (Max Heap Size) → 1/4th of RAM (default)
Example: -Xms1024m -Xmx2048m (Sets heap size to 1GB min, 2GB max)

->Stack Memory (Fixed per thread)

Default size: 512 KB – 1MB per thread
Configurable using -Xss (Example: -Xss512k sets 512KB per thread)

->Metaspace (Java 8+)

Dynamic Size (No upper limit, expands as needed)
Default: 21MB – 1GB (configurable via -XX:MaxMetaspaceSize)
=====================
JVM Execution Flow
==================
->Class Loading → Bytecode is loaded into the Method Area.
->Memory Allocation → Objects are stored in the Heap, local variables in the Stack.
->Execution → The Execution Engine (Interpreter or JIT Compiler) converts bytecode to machine code.
->Garbage Collection → JVM frees memory by removing unused objects from the Heap.



============================
JVM Memory Model Diagram
=============================
+----------------------------+
|      JVM Memory Model      |
+----------------------------+
| 1. Method Area (Class Metadata, Static Vars) |
+----------------------------------------------+
| 2. Heap (Objects, Instance Variables)       |
+----------------------------------------------+
| 3. Stack (Local Variables, Method Calls)    |
+----------------------------------------------+
| 4. PC Register (Current Instruction)        |
+----------------------------------------------+
| 5. Native Method Stack (Native Calls)       |
+----------------------------------------------+


===============
Summary
=============
✅ JVM provides a runtime environment for Java applications.
✅ Memory is divided into Method Area, Heap, Stack, PC Register, and Native Stack.
✅ Garbage Collector manages memory efficiently.
✅ Heap and Method Area are shared, Stack and PC Register are thread-specific.




===================================
Where to Configure JVM Memory Settings?
========================================
->using CMD

You can set JVM memory parameters while running your Java program using the java command:

java -Xms1024m -Xmx2048m -Xss512k -XX:MaxMetaspaceSize=512m -jar yourApp.jar


->IDE
Go to: Run → Run Configurations
Select your Java application.
Go to the "Arguments" tab.
Add JVM arguments in the "VM Arguments" box

-Xms1024m -Xmx2048m -Xss512k -XX:MaxMetaspaceSize=512m


->In Application Server Configuration (Tomcat, WildFly, etc.)

Edit setenv.sh (Linux/macOS) or setenv.bat (Windows) in the bin directory:

export CATALINA_OPTS="-Xms1024m -Xmx2048m -Xss512k -XX:MaxMetaspaceSize=512m"


->In a Dockerfile (for Containerized Java Applications)

If you are running Java in a Docker container, you can set memory options in the Dockerfile:

CMD ["java", "-Xms1024m", "-Xmx2048m", "-Xss512k", "-XX:MaxMetaspaceSize=512m", "-jar", "yourApp.jar"]


=============================================
Difference Between JDK, JRE, and JVM in Java
=============================================

->Java development and execution require three key components:
JVM (Java Virtual Machine)
JRE (Java Runtime Environment)
JDK (Java Development Kit)

->JVM is an abstract machine responsible for running Java applications by converting Java bytecode (.class files) into machine code.

Key Responsibilities of JVM:-
✅ Loads, verifies, and executes Java bytecode
✅ Performs Just-In-Time (JIT) compilation
✅ Manages memory through Garbage Collection (GC)
✅ Provides security features like sandboxing

JVM does not include development tools (like compilers), it is just a runtime environment.


 JVM Components:-
1ClassLoader → Loads .class files into memory.
2️Runtime Memory Areas (Method Area, Heap, Stack, etc.) → Manages memory allocation.
3️Execution Engine → Converts bytecode to machine code (Interpreter + JIT Compiler).
4️Garbage Collector (GC) → Removes unused objects from memory.

->JVM is platform-dependent, meaning it is different for Windows, Linux, and macOS. But the bytecode (.class files) is platform-independent and runs on any JVM.

->JRE is a package that contains everything needed to run a Java program but does not include development tools (like compilers or debuggers).

 JRE Includes:
✅ JVM → Executes Java bytecode.
✅ Java Class Libraries (rt.jar, java.base module, etc.) → Contains built-in Java classes (like java.lang, java.util).
✅ Supporting Files → Configuration files, security settings, etc.

->Use Case: If you only want to run Java applications (not develop them), JRE is enough.


->JDK is a complete development package that includes JRE + development tools to write, compile, and debug Java programs


 JDK Includes:
✅ JRE (JVM + Java Libraries)
✅ Java Compiler (javac) → Converts Java code (.java) into bytecode (.class).
✅ Debugger (jdb) → Helps in debugging Java programs.
✅ JavaDoc (javadoc) → Generates API documentation.
✅ Other Tools → jar, jconsole, jstat, etc.

->Use Case: If you are a developer and need to write Java programs, you need the JDK.


Feature	JVM          (Java Virtual Machine)	          JRE (Java Runtime Environment)	     JDK (Java Development Kit)
Purpose  	     Executes Java bytecode	        Runs Java applications         	        Develops and runs Java programs
Includes	     Only JVM	                        JVM + Java Libraries	                JRE + Compiler + Development Tools
Tools	             No compiler, no debugging tools	No compiler, no debugging tools	        Includes javac, jdb, javadoc
Needed For	      Running Java bytecode	        Running Java programs	                Writing, compiling, and running Java code
Platform Dependency	Platform-dependent	        Platform-independent	                Platform-independent



+----------------------+
|      JVM            |
+----------------------+
|  Heap Memory        |  <--- Stores object instances
+----------------------+
|  Stack Memory       |  <--- Stores local variables, method calls
+----------------------+
|  Metaspace          |  <--- Stores class metadata, method info
+----------------------+



=============================
How They Work Together
============================
1️You write Java code (.java file)
2️JDK (javac) compiles the code into bytecode (.class file)
3️JRE loads the Java class libraries
4️JVM executes the bytecode by converting it into machine code

=================================
Why is String Immutable in Java?
==================================
->In Java, String is immutable, meaning that once a String object is created, it cannot be changed. 
->Any modification (like concatenation, replacement, or conversion to uppercase) results in a new String object instead of modifying the existing one.
->In Java, String is immutable, meaning once created, its value cannot be changed. 
->If you modify a String, Java creates a new object instead of changing the existing one.

===============================
Reasons for String Immutability
===============================
1. Security :-
================
->String is widely used in passwords, database connections, and file paths.
->If String were mutable, hackers could modify a String value, leading to security issues.

->example:Password Modification Risk (If String were mutable)

class SecurityExample {
    public static void main(String[] args) {
        String password = "Admin@123";  // Secure password
        password.replace("Admin@123", "HackedPassword"); // If mutable, this would change the original
        System.out.println(password);  // Still prints "Admin@123" due to immutability
    }
}
->Since String is immutable, hackers cannot change the password in memory.

2. Thread-Safety in Multithreading :-
========================================
->In a multi-threaded environment, multiple threads can access the same String object safely.
->If String were mutable, one thread modifying a shared String would affect all other threads

->Example: Shared Resource in Multi-Threading
class ThreadExample {
    public static void main(String[] args) {
        String sharedData = "TransactionID123";
        
        // Thread 1 tries to modify it
        new Thread(() -> {
            String newData = sharedData.replace("123", "456");
            System.out.println("Thread 1 modified: " + newData);
        }).start();

        // Thread 2 reads the original data safely
        new Thread(() -> {
            System.out.println("Thread 2 reads: " + sharedData);
        }).start();
    }
}
->The original sharedData remains unchanged, avoiding concurrency issues.

3. Efficient Memory Management (String Pooling):-
==================================================
->Java optimizes String objects using String Pool (Heap memory).
->If String were mutable, modifying one reference would affect all others using the same object.

->Example: String Pool Optimization

public class StringPoolExample {
    public static void main(String[] args) {
        String s1 = "Hello";  // Stored in String Pool
        String s2 = "Hello";  // Reuses same object from String Pool

        System.out.println(s1 == s2);  // True (same memory reference)
    }
}
->Java avoids duplicate objects in memory, making applications faster.

4. Caching and Hashcode Performance :-
========================================
->String's hashcode is cached for better performance in hash-based collections (like HashMap).
->If String were mutable, its hashcode would change, making retrieval slow.
->Example: HashMap with Immutable String

import java.util.HashMap;
public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, String> map = new HashMap<>();
        String key = "username";
        map.put(key, "Swapnil");

        key = key + "123";  // Even though we modify key, original key in HashMap remains the same
        
        System.out.println(map.get("username"));  // Still retrieves "Swapnil"
    }
}

->String being immutable ensures consistent hashcode values in HashMap.

=======================================
Real-Time Scenarios of Immutable String
========================================
->Scenario 1: Database Connection Strings

String dbUrl = "jdbc:mysql://localhost:3306/mydb";  
dbUrl.replace("mydb", "otherdb");  // Doesn't modify original dbUrl
System.out.println(dbUrl);  // Still prints "jdbc:mysql://localhost:3306/mydb"

-> Prevents accidental modification of database URLs.

->Scenario 2: Using String as a Key in Caching

HashMap<String, String> cache = new HashMap<>();
cache.put("user1", "Swapnil");
cache.put("user2", "Amit");

// Even if we modify the key string, the original reference is unchanged
String key = "user1";
key = key + "_modified";  

System.out.println(cache.get("user1"));  // Still retrieves "Swapnil"

-> Ensures stable keys in cache systems.
==================
Conclusion
===============
✔ String is immutable for security, performance, and memory efficiency.
✔ Helps in multi-threading, caching, and prevents accidental modifications.
✔ Used in critical areas like passwords, caching, and database connections

public class reverseString{
public static void main(String[] args){
String str="Swapnil";
StringBuilder sb=new StringBuilder(str).reverse().toString();
Sop(sb)
}
}
=========================================================================================================================================================================

CompletableFuture in Java?
==========================
->CompletableFuture is a class introduced in Java 8 under the java.util.concurrent package.
->It allows you to write asynchronous, non-blocking, and concurrent code in a more readable and structured way.

Why do we use CompletableFuture?
================================
To run tasks in the background without blocking the main thread.
To run multiple tasks in parallel and combine their results.
To handle long-running API calls, DB operations, file reading, etc. efficiently.

 Key Benefits of CompletableFuture
===================================
 Non-blocking:-	Allows asynchronous execution without waiting for completion
Better performance:-	Efficient CPU usage via parallelism.
 Easy chaining:-	You can chain multiple async operations cleanly (thenApply, thenCombine, etc.).
Error handling:-	Easily handle exceptions using exceptionally() or handle().

Disadvantages
=============
Complex debugging:-	Async code can be harder to debug than synchronous code.
Thread management:-	Improper thread pool usage can lead to performance issues.
Callbackhell	:-Poor design can lead to unreadable chaining of futures.


Basic Example of CompletableFuture
===================================
import java.util.concurrent.CompletableFuture;

public class CompletableFutureExample {
    public static void main(String[] args) {
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            // Simulating API or DB call
            try {
                Thread.sleep(2000); // 2 seconds delay
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return "Hello from background task!";
        });

        // Main thread continues...
        System.out.println("Doing other work...");

        // Get result when done (blocking)
        String result = future.join(); // same as get() but unchecked
        System.out.println("Result: " + result);
    }
}


OP:-Doing other work...
Result: Hello from background task!

Chaining CompletableFuture
==========================
CompletableFuture.supplyAsync(() -> "Java")
    .thenApply(str -> str + " Developer")
    .thenApply(str -> str.toUpperCase())
    .thenAccept(System.out::println);

OP:JAVA DEVELOPER

Real-time Example – Parallel API calls
========================================

public class ParallelExample {
    public static void main(String[] args) {
        CompletableFuture<String> user = CompletableFuture.supplyAsync(() -> {
            return "User Info";
        });

        CompletableFuture<String> order = CompletableFuture.supplyAsync(() -> {
            return "Order Info";
        });

        // Combine both results when both are done
        CompletableFuture<String> result = user.thenCombine(order, (u, o) -> u + " + " + o);

        System.out.println("Final Result: " + result.join());
    }
}

Op:-Final Result: User Info + Order Info

Exception Handling with CompletableFuture
=========================================

CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    if (true) throw new RuntimeException("Something went wrong!");
    return "Success";
}).exceptionally(ex -> {
    return "Fallback Result due to: " + ex.getMessage();
});

System.out.println(future.join());


op:-Fallback Result due to: Something went wrong!

Summary
========
supplyAsync()	Runs a task asynchronously that returns a result
thenApply()	Transforms the result
thenCombine()	Combines two CompletableFuture results
thenAccept()	Consumes the result
exceptionally()	Handles errors
join() / get()	Waits for the result (blocking)
==================================================================================================================================

What is Spring WebFlux?
=========================
->Spring WebFlux is a part of the Spring 5 framework introduced to support reactive programming using a non-blocking, asynchronous model for building web applications.
->It is based on Project Reactor, which provides reactive types like:
Mono<T> – 0 or 1 result
Flux<T> – 0 to N results

 Why use WebFlux?
==================
->Traditional Spring MVC is blocking and synchronous – every request is handled by a thread, and if the request waits (e.g., slow DB call), the thread is blocked.
->WebFlux solves this by using event-loop and reactive streams, which handle more concurrent requests with fewer resources

Use Cases (Where it's Used)
=========================
Streaming large datasets	:-Efficient handling using Flux<T>
Real-time apps	:-Chat, stock updates, IoT dashboards
High-concurrency APIs:-	More users with fewer threads
Microservices communication:-	With backpressure support
Third-party async APIs:-	Don't block waiting for external systems


Advantages of WebFlux
========================
Non-blocking I/O	:-Uses less memory, better for scalability
High performance	:-Ideal for high-load environments
Streaming support	:-Can send and receive data streams
Less thread usage	:-Efficient CPU usage

Disadvantages
=============
Complex debugging	:-Stack traces are harder to trace
Steep learning curve	:-Requires understanding of reactive concepts
Not suitable for all apps:-	Overhead if you're building simple apps
Poor JDBC support:-	JDBC is blocking; not ideal in WebFlux apps unless reactive DB drivers are used (like R2DBC)


Key Components
==============
Mono<T>	:-Represents 0 or 1 result (like Optional)
Flux<T>	:-Represents stream of 0 to N items
WebClient	:-Replaces RestTemplate for async REST calls
RouterFunction	:-Functional-style route configuration
@RestController	:-Still supported with Mono or Flux return types

Simple WebFlux Example
========================

@RestController
public class UserController {

    @GetMapping("/hello")
    public Mono<String> sayHello() {
        return Mono.just("Hello from WebFlux!");
    }

    @GetMapping("/numbers")
    public Flux<Integer> getNumbers() {
        return Flux.range(1, 5);
    }
}

->This is a standard Spring Boot REST controller, but returning reactive types (Mono, Flux) instead of regular objects.
->Spring WebFlux is non-blocking and can stream data using these types.


Endpoints & Output:
=====================

->  /hello	Returns a Mono<String> with the value "Hello from WebFlux!"	"Hello from WebFlux!"
->/numbers	Returns a Flux<Integer> of numbers from 1 to 5 (excluding 5)	[1, 2, 3, 4]

Note: The output may be rendered as a JSON array depending on your browser/tool (e.g., Postman).


Call External API using WebClient (Non-blocking)
================================================

@Service
public class GitHubService {

    WebClient webClient = WebClient.create("https://api.github.com");

    public Mono<String> getUser(String username) {
        return webClient.get()
                .uri("/users/" + username)
                .retrieve()
                .bodyToMono(String.class);
    }
}

->WebClient is the non-blocking alternative to RestTemplate.
->It sends a GET request to https://api.github.com/users/{username}.
->The response (usually JSON) is returned as a Mono<String>


Example usage:
================
->Suppose you inject this service into a controller:

@Autowired
private GitHubService gitHubService;

@GetMapping("/github/{username}")
public Mono<String> getGitHubUser(@PathVariable String username) {
    return gitHubService.getUser(username);
}

-> Calling:
GET /github/octocat

->Output:
Returns the JSON details of the GitHub user octocat, like:

{
  "login": "octocat",
  "id": 1,
  "node_id": "MDQ6VXNlcjE=",
  "avatar_url": "...",
  ...
}

 RouterFunction & Handler (Functional Style)
===============================================
@Bean
public RouterFunction<ServerResponse> route() {
    return RouterFunctions.route(GET("/hello"), 
        request -> ServerResponse.ok().bodyValue("Hello Functional!"));
}


->This uses functional programming style instead of @RestController.
->Defines a route: GET /hello → returns "Hello Functional!".

This is a more declarative way of creating endpoints.
->When you hit GET /hello, you get:Hello Functional!

Mono vs Flux
===============
Feature	       Mono	                                     Flux
Meaning	      0 or 1 value	                 0 to N values
Use	      Single object (User, Product)	List/Stream of items (Orders, Events)
Example      Mono<String>	                Flux<Integer>

Real-time Scenario – Streaming Stock Prices
============================================

@GetMapping("/stocks")
public Flux<Double> streamStockPrices() {
    return Flux.interval(Duration.ofSeconds(1))
               .map(i -> 100 + Math.random() * 10);
}

->This endpoint sends a new stock price every second to the client — perfect for dashboards.

Summary
========
Feature	                     WebFlux
Model	        Non-blocking, Reactive
Types	        Mono, Flux
Ideal for	High concurrency, Streaming
Replaces	RestTemplate → WebClient
DB Support	Use R2DBC for non-blocking DB access
Use when	You need high performance with async I/O

=============================================================================================================

Disadvantages of using RestApi
===============================

->Using REST APIs comes with many advantages, such as simplicity, scalability, and statelessness. However, REST APIs also have some disadvantages, especially in complex, large-scale, or real-time systems. 

-> Below are some of the major disadvantages of REST APIs, with proper explanations and real-time examples:

1.Over-fetching and Under-fetching
=================================

->When your REST API gives too much or too little data.

->You're ordering a pizza from an app. You only need the pizza name and price.
GET /pizza/123

->But the API sends:
{
  "name": "Margherita",
  "price": 299,
  "ingredients": ["Cheese", "Tomato"],
  "created_by": "Chef Mario",
  "last_updated": "2024-01-01",
  ...
}

->You just needed name & price, but you got extra data = over-fetching.
->Now, if you also need the restaurant address, you need another API call like:
GET /pizza/123/restaurant

-> This is under-fetching. One API call is not enough — more round-trips!



2.Multiple Round Trips
======================

->To display one screen/page, you have to call multiple APIs, which slows down your app.

->In your Amazon app, to show a user dashboard, you might need:

User profile (GET /user/123)

User’s orders (GET /user/123/orders)

Each order's items (GET /orders/45/items, /orders/46/items, ...)

->That’s 4-5 separate calls instead of 1.This increases load time, especially with slow internet like 3G.


3.No Real-Time Support
======================

->The server cannot send updates automatically to the user.

->In a stock market app, prices change every second.

->With REST, your app has to keep asking:GET /stock/price every 5 seconds

->This is called polling, and it’s not efficient.

-> Better solution? Use WebSockets or Server-Sent Events — they push updates to you instantly like chat messages or notifications.


4.Inconsistent Error Handling
==============================
->Every REST API might return errors in different ways.

->If your request is unauthorized:One API says:{ "error": "Invalid Token", "code": 401 }

->Another says:{ "message": "Unauthorized Access" }

->Now your app has to write extra code to understand both formats.There's no fixed standard for how REST errors should look.

5.Security Issues
=================
->REST APIs are often exposed to the internet, so they must be secured.

->Let’s say this endpoint exists:GET /users/all

->If there is no token check, anyone could see all users!

-> If you don’t use proper security like JWT tokens, HTTPS, or OAuth, hackers can:Steal tokens,Inject malicious code,Access sensitive data

6. No Built-in Versioning
=========================

->REST doesn’t give you a way to manage different versions of your API.

->Today your API returns:{ "name": "Swapnil", "email": "abc@example.com" }

->Next week you change it to:{ "firstName": "Swapnil", "emailAddress": "abc@example.com" }

->Older mobile apps will crash if they expect the old format.

-> To fix this, developers manually add versions like:
GET /api/v1/users
GET /api/v2/users

->But it adds extra work to maintain both versions


7.Not Good for Complex Workflows
=================================

->REST is good for basic tasks, but not ideal for things that need multiple steps or transactions.

->Booking a flight:Lock seat,Enter passenger details,Make payment,Confirm ticket

->REST forces you to do:POST /seat/lock
POST /passenger/add
POST /payment
POST /confirm

-> It’s not smooth, error-prone, and hard to rollback.

->Better tools like GraphQL or gRPC handle such complex flows more elegantly.

Summary Table (Simplified)
=============================
❌ Disadvantage	                      🤯 Real-Life Problem

Over-fetching/Under-fetching	You get too much or too little data from API
Multiple Round Trips	        App needs many calls to show one screen — becomes slow
No Real-Time	                Can't push updates to users — polling required
Error Format Confusion	        Every API sends errors in different formats
Security Risks	                Without JWT & HTTPS, anyone can misuse your API
No Version Control	        Older clients can break when API changes
Hard for Multi-Step Flows	REST is not good for booking, transactions, or workflows

When to Use REST?
=================

->Simple CRUD apps (Create/Read/Update/Delete)

->Blog, e-commerce, profile management

->You don’t need real-time updates

========================================================================================================================================================


What is AppDynamics?
====================
->AppDynamics is an Application Performance Management (APM) and observability tool that helps you monitor the performance of your applications, infrastructure, and user experiences in real time.

->It is used by developers, DevOps teams, and IT operations to
Detect and fix performance bottlenecks.
Get end-to-end visibility of distributed applications.
Monitor infrastructure, databases, APIs, and user transactions.


What Does AppDynamics Monitor?
===============================
Component	             What it tracks
Application	            Java, .NET, Node.js, PHP apps: response time, exceptions, errors
Database	            Slow queries, query response time, DB health
Infrastructure	            CPU, memory, disk usage of servers or containers
Business Transactions	    End-to-end flow from frontend to backend
User Experience	            Page load time, user clicks, session paths (using Real User Monitoring - RUM)


 What Do You Have to Do (As a Developer/Engineer)?
===================================================
 1. Install the AppDynamics Agent
->For a Java application:Add the AppDynamics Java Agent JAR to your application.
Configure it using:-javaagent:/path/to/appdynamics/javaagent.jar
->Provide your AppDynamics account credentials and application name in controller-info.xml or through environment variables.

2. Configure Business Transactions
->AppDynamics auto-discovers most transactions (like REST endpoints).
->You can create custom business transactions (e.g., based on URL patterns or methods).

3. Monitor Metrics via Dashboard
->Use the AppDynamics UI to see:Response times,Throughput,Errors,Bottlenecks,Memory leaks,Thread usage

 4. Set Up Alerts
->Set up health rules (e.g., alert if CPU > 80%).
->You’ll get alerts via email, Slack, etc.

5. Troubleshooting
->When a performance issue is reported (e.g., slow transaction), go to:
Transaction snapshots (drill down to method-level performance)
Call graphs (see which method/database/API call is slow)
Error logs

Benefits of Using AppDynamics
==============================

Advantage	                  Description
🔎 Deep visibility	        See how each part of your app performs end-to-end
⚡ Faster troubleshooting	Pinpoint root cause of slowness
📊 Business insights	        Map technical issues to business impact
🔔 Proactive alerts	        Avoid downtime with threshold-based alerts
☁️ Cloud support	                Supports AWS, Azure, GCP deployments


Disadvantages
===============
Drawback	                       Details
💸 Expensive	         Licensing can be costly for large apps
⚙️ Learning curve	 Setup and dashboard tuning takes time
📉 Performance overhead	 Slight performance impact from the agent itself (minimal but must be monitored)


 Real-Time Example:
===================
->You work on a Spring Boot Java app deployed on AWS. Sometimes, users complain the app is slow during peak hours.
->With AppDynamics, you can:Monitor /login and /checkout endpoints.
Find that the /checkout takes 6s due to a slow MySQL query.
Fix the query → app runs faster → fewer complaints.


=============================================================================

=================================
Disadvantafes of using Rest API
================================

->No built-in security
REST itself doesn’t have security. You have to add things like authentication (e.g., tokens) separately.
Example: Anyone can access your REST API if you don't secure it properly — like leaving your front door open.

->Too much data over network
REST APIs often send more data than needed (especially with JSON), which can slow things down.
Example: If you just need a user’s name, but the API sends name, age, address, and photo — that’s wasteful.

-> No state (Statelessness)
REST APIs don’t remember anything about previous requests. Every request is treated as new.
Example: If you're shopping online, the API doesn’t remember your cart — you must send it again with every request.

->Versioning problems
When APIs change (e.g., new fields added), older apps may break if the new API isn’t backward-compatible.
Example: If your app uses version 1 of an API and the company switches to version 2, your app might stop working unless you upgrade.

->Complex for real-time
REST is not designed for real-time data updates (like chat apps or live sports scores). For that, WebSockets or gRPC is better.
Example: In a chat app, REST would keep polling for new messages — which is not efficient.

->HTTP-only
REST relies only on HTTP protocol. If you want to use something else (like message queues), REST isn't flexible.
======================================================================================================================================

COSUMER & BICONSUMER
=======================

->Consumer<T> is a functional interface that takes one input and returns nothing.

@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}

->BiConsumer<T, U> is a functional interface that takes two inputs and returns nothing.

@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}


Key Differences:
================
Feature	                 Consumer<T>	                           BiConsumer<T, U>
Input Parameters	Takes 1 input	                         Takes 2 inputs
Return Type	        void (does not return anything)	         void (does not return anything)
Used For	        Performing action on single object	 Performing action involving two objects
Example Use Case	Print a name	                         Add a name and age into a map


Realtime Examples
==================
 1. Consumer Example – Print Customer Name
============================================

import java.util.function.Consumer

public class ConsumerExample{
public static void main(String[] args){
Consumer<String> greetCustomer=name ->System.out.println("Hello," +name+ "!");
greetCustomer.accept("Swapnil");
}
}

Op:-Hello, Swapnil!

->Scenario:Imagine you're building a UI where you show greetings to customers by name when they log in.

2. BiConsumer Example – Add Name and Age into a Map
====================================================

import java.util.function.BiConsumer;
import java.util.HashMap;
import java.util.Map;

public class BiConsumerExample {
    public static void main(String[] args) {
        Map<String, Integer> customerAgeMap = new HashMap<>();

        BiConsumer<String, Integer> addCustomerAge = (name, age) ->
            customerAgeMap.put(name, age);

        addCustomerAge.accept("Swapnil", 30);
        addCustomerAge.accept("Amit", 25);

        System.out.println(customerAgeMap);
    }
}


OP:-{"Swapnil"=30, "Amit"=25}

-> Scenario:You're saving customer name and age into a map (e.g., for registration or report purposes).


More Realtime Scenarios
=========================
Scenario	                      Use Consumer	        Use BiConsumer
Logging a single event	              Consumer<String>	
Sending email to user	              Consumer<User>	
Storing username & password		                       BiConsumer<String, String>
Creating a price list (item, price)		               BiConsumer<String, Double>
Formatting a single string	       Consumer<String>	
Setting config (key, value)		                       BiConsumer<String, String>

Summary in One Line:
====================
->Use **Consumer** when you need to operate on a single input.

->Use **BiConsumer** when you need to operate on two related inputs.


****************FUNCTION/BIFUNCTION**************
In Java, Function and BiFunction are functional interfaces available in the java.util.function package, introduced with Java 8. 
These interfaces represent functions with one or two parameters and are often used in lambda expressions, method references, and functional programming.

1. Function Interface
The Function<T, R> interface represents a function that takes a single argument of type T and returns a result of type R. It has a single abstract method apply:

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

T: the type of the input argument to the function.
R: the type of the result of the function.

Example: Using Function to Convert Strings to Uppercase
Suppose you want to convert a list of strings to uppercase. You can use a Function to define this behavior.

import java.util.function.Function;
import java.util.List;
import java.util.stream.Collectors;

public class FunctionExample {
    public static void main(String[] args) {
        // List of strings to convert to uppercase
        List<String> names = List.of("Alice", "Bob", "Charlie");

        // Define a Function to convert a string to uppercase
        Function<String, String> toUpperCase = String::toUpperCase;

        // Apply the Function to each name in the list
        List<String> upperCaseNames = names.stream()
                                           .map(toUpperCase)
                                           .collect(Collectors.toList());

        System.out.println("Uppercase Names: " + upperCaseNames); // Output: [ALICE, BOB, CHARLIE]
    }
}



Explanation:

toUpperCase is a Function that takes a String as input and returns a String in uppercase.
.map(toUpperCase) applies this function to each element in the names list, converting all names to uppercase.
The result, [ALICE, BOB, CHARLIE], is printed to the console.

Real-World Use Case for Function
Consider an e-commerce application where you need to apply a discount to product prices. You could create a Function<Double, Double> to calculate the discounted price for each product.

import java.util.function.Function;
import java.util.List;

public class DiscountCalculator {
    public static void main(String[] args) {
        List<Double> prices = List.of(100.0, 200.0, 300.0);

        // Define a Function to apply a 10% discount
        Function<Double, Double> discount = price -> price * 0.9;

        prices.stream()
              .map(discount)
              .forEach(System.out::println); // Output: 90.0, 180.0, 270.0
    }
}


2. BiFunction Interface
The BiFunction<T, U, R> interface represents a function that takes two arguments of types T and U and returns a result of type R. It has a single abstract method apply:

@FunctionalInterface
public interface BiFunction<T, U, R> {
    R apply(T t, U u);
}

T: the type of the first input argument to the function.
U: the type of the second input argument to the function.
R: the type of the result of the function.

Example: Using BiFunction for Arithmetic Operations
Let’s say you want to add two integers. You can use a BiFunction<Integer, Integer, Integer> to define this behavior.


import java.util.function.BiFunction;

public class BiFunctionExample {
    public static void main(String[] args) {
        // Define a BiFunction to add two integers
        BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

        int result = add.apply(5, 10);
        System.out.println("Sum: " + result); // Output: 15
    }
}
	
	Explanation:

add is a BiFunction that takes two integers as input and returns their sum.
add.apply(5, 10) calls the apply method to add 5 and 10, resulting in 15.


Real-World Use Case for BiFunction
In a banking application, you may need to calculate the interest for a given principal amount and rate. You can use a BiFunction<Double, Double, Double> to calculate the simple interest.

import java.util.function.BiFunction;

public class InterestCalculator {
    public static void main(String[] args) {
        // Define a BiFunction to calculate interest
        BiFunction<Double, Double, Double> calculateInterest = (principal, rate) -> principal * rate / 100;

        double interest = calculateInterest.apply(1000.0, 5.0); // Principal = 1000, Rate = 5%
        System.out.println("Interest: " + interest); // Output: 50.0
    }
}

Summary
Function<T, R> is used when you have a single input and output. Example: Function<String, String> for converting a string to uppercase.
BiFunction<T, U, R> is used when you have two inputs and an output. Example: BiFunction<Double, Double, Double> for calculating interest from principal and rate.
Both Function and BiFunction are powerful tools in Java functional programming, making it easy to write concise and reusable code, especially when combined with streams and other functional programming techniques.

=========================================================================================================================================================================================

**************PREDICATE****************

->In Java, a Predicate is a functional interface introduced in Java 8 as part of the java.util.function package.

->It represents a single-argument function that returns a boolean value, indicating whether a given condition is met or not. 

->Predicates are commonly used to filter collections, implement conditional logic, and create more readable code by abstracting conditional checks

Predicate Interface Basics
The Predicate<T> interface is defined as follows:

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}

T: the type of the input to the predicate.
test(T t): the single abstract method, which takes an argument of type T and returns a boolean. This is where you define the condition you want to check.

Commonly Used Predicate Methods:-
==================================
Besides test, the Predicate interface provides several useful default and static methods for combining and manipulating predicates:

and(Predicate other): Returns a composed predicate that represents a logical "AND" of this predicate and another.
or(Predicate other): Returns a composed predicate that represents a logical "OR" of this predicate and another.
negate(): Returns a predicate that represents the logical negation of this predicate.
isEqual(Object targetRef): Returns a predicate that tests if two arguments are equal.

======================================
Real-Time Examples and Use Cases:-
======================================
Example 1: Filtering a List of Strings
Suppose you have a list of names and want to filter out only those names that start with the letter "A".


import java.util.function.Predicate;
import java.util.List;
import java.util.stream.Collectors;

public class PredicateExample {
    public static void main(String[] args) {
        List<String> names = List.of("Alice", "Bob", "Andrew", "Charlie", "Ann");

        // Define a Predicate that checks if a string starts with "A"
        Predicate<String> startsWithA = name -> name.startsWith("A");

        // Filter names using the Predicate
        List<String> filteredNames = names.stream()
                                          .filter(startsWithA)
                                          .collect(Collectors.toList());

        System.out.println("Names that start with 'A': " + filteredNames);
        // Output: Names that start with 'A': [Alice, Andrew, Ann]
    }
}
Explanation:

startsWithA Predicate: This predicate checks if a string starts with "A".
filter method: This method in the Stream API uses the predicate to filter out items that match the condition, returning only names that start with "A".
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Example 2: Checking if Numbers are Positive and Even
Suppose you want to check if a number is positive and even. You can create two predicates and combine them using and to achieve this.

import java.util.function.Predicate;

public class NumberPredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isPositive = number -> number > 0;
        Predicate<Integer> isEven = number -> number % 2 == 0;

        int number = 4;

        // Combined Predicate for positive and even
        boolean result = isPositive.and(isEven).test(number);

        System.out.println("Is number positive and even? " + result);
        // Output: Is number positive and even? true
    }
}
Explanation:

isPositive Predicate: Checks if a number is greater than 0.
isEven Predicate: Checks if a number is even.
Combined Predicate: isPositive.and(isEven) combines both conditions, so the test method returns true only if both are true.

Use Case: Employee Management System
In an employee management application, suppose you want to filter employees based on different criteria like department, salary, and age.


import java.util.function.Predicate;
import java.util.List;
import java.util.stream.Collectors;

class Employee {
    String name;
    String department;
    int age;
    double salary;

    Employee(String name, String department, int age, double salary) {
        this.name = name;
        this.department = department;
        this.age = age;
        this.salary = salary;
    }

    @Override
    public String toString() {
        return name + " (" + department + ", " + age + " years, $" + salary + ")";
    }
}

public class EmployeePredicateExample {
    public static void main(String[] args) {
        List<Employee> employees = List.of(
            new Employee("Alice", "HR", 30, 50000),
            new Employee("Bob", "IT", 25, 70000),
            new Employee("Charlie", "Finance", 35, 80000),
            new Employee("Diana", "IT", 28, 75000)
        );

        // Predicate for employees in the IT department
        Predicate<Employee> isITDepartment = emp -> "IT".equals(emp.department);

        // Predicate for employees with salary over $60000
        Predicate<Employee> hasHighSalary = emp -> emp.salary > 60000;

        // Combined Predicate for IT department and high salary
        List<Employee> itHighSalaryEmployees = employees.stream()
                                                        .filter(isITDepartment.and(hasHighSalary))
                                                        .collect(Collectors.toList());

        System.out.println("IT department employees with salary over $60000:");
        itHighSalaryEmployees.forEach(System.out::println);
    }
}

Explanation:-

isITDepartment Predicate: Checks if an employee is in the IT department.
hasHighSalary Predicate: Checks if an employee’s salary is greater than $60000.
Combined Predicate: Filters the list of employees to include only those in the IT department with a high salary.


===================================
Summary of Predicate Use Cases:-
=================================
Filter Collections: Predicate is widely used to filter lists based on certain conditions (like filtering names, numbers, or objects based on attributes).
Conditional Checks: Used to implement conditional logic in a more readable and functional way.
Lambdas and Method References: Commonly used in lambda expressions and method references for concise code.

======================================
Key Advantages of Using Predicates:-
====================================
Readability: Clear and expressive code by representing conditions as separate, reusable objects.
Modularity: Easier to change filtering logic by modifying predicates.
Code Reusability: Predicates can be composed (and, or, negate) to create complex conditions from simple ones.
In summary, Predicate is a powerful tool in Java for building flexible, concise, and readable conditional logic, especially useful in the context of filtering and functional programming.

================================================================================================================================================================
Function & Predicate
====================

->Function<T, R> is a functional interface in Java 8 that takes one argument of type T and returns a result of type R

-> Package: java.util.function.Function

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}

-> Real-Time Example: Convert String to Length

public class FunctionExample {
public static void main(String[] args){

Function<String,Integer> stringLength = str-> str.length();
Sysytem.out.println("Length of 'developer' = " + stringLength.apply("Developer")) 

}
}

->op:Length of 'developer' = 9


-> Use case: Often used in data transformation, mapping, DTO conversion, stream .map() operations, etc.

->Predicate<T> is a functional interface that takes one argument of type T and returns a boolean value (true/false).

-> Package: java.util.function.Predicate

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}


-> Real-Time Example: Check if Age > 18

import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        Predicate<Integer> isAdult = age -> age > 18;

        System.out.println("Is 20 an adult? " + isAdult.test(20));
        System.out.println("Is 16 an adult? " + isAdult.test(16));
    }
}

->op :Is 20 an adult? true     Is 16 an adult? false

->Use case: Used in filtering, validations, condition checking, and .filter() in streams.

->Combined Example: Filtering List

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class EmployeeFilter {

    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Alice", "Mike", "Bob", "Zara");

        Predicate<String> nameStartsWithA = name -> name.startsWith("A");
        Function<String, String> toUpperCase = name -> name.toUpperCase();

        List<String> result = names.stream()
                                   .filter(nameStartsWithA)
                                   .map(toUpperCase)
                                   .collect(Collectors.toList());

        System.out.println("Filtered and Transformed Names: " + result);
    }
}

->Output: Filtered and Transformed Names: [ALICE]


->Can a Predicate return null?
Answer: No. Predicate.test(T t) returns only a boolean — either true or false.

->How do you combine multiple predicates?
Using and(), or(), and negate():
Predicate<String> startsWithA = s -> s.startsWith("A");
Predicate<String> endsWithZ = s -> s.endsWith("z");

Predicate<String> combined = startsWithA.and(endsWithZ);

->Can you use Function and Predicate together in Streams?
Answer: Yes, very commonly.

list.stream()
    .filter(predicate)
    .map(function)
    .collect(Collectors.toList());


->Is Function<T, Boolean> same as Predicate<T>?
 Technically yes in behavior, but:
Predicate is specifically meant to return boolean (more readable)
Function<T, Boolean> is more general-purpose
Preferred: Use Predicate<T> when you're testing a condition.


->What is the difference between Consumer, Function, and Predicate?
Interface	Input	Output	Purpose
Function	T	R	Transform data
Predicate	T	boolean	Filter / Test condition
Consumer	T	void	Perform action (side effect)

->Interview-Friendly One-Liner:
Predicate is used to test a condition and returns a boolean, mostly used in filtering. 
Function transforms input to output and is commonly used in mapping and conversions.
 Both are functional interfaces from Java 8 and widely used in streams.

------------------------------------------------------------------------------------------------------------------------------------------
In Spring Spring Boot, the @EnableAutoConfiguration annotation is a key component that facilitates automatic application context configuration. Here's a breakdown of its functionality:

Purpose:

Instructs Spring Boot to automatically configure the Spring application context based on the dependencies present in your classpath.
This means Spring Boot analyzes the libraries you've included and attempts to configure beans and functionalities related to those libraries.
Benefits:

Reduced boilerplate code: By automatically configuring common beans, @EnableAutoConfiguration saves you from writing extensive XML configuration files or manual Java configuration classes.
Faster development: This reduces development time and effort, allowing you to focus on your application's core logic.
Consistent configurations: Spring Boot's opinionated defaults promote consistent and reliable configurations across various applications.
How it works:

Spring Boot scans your classpath: It identifies the libraries you've included in your project.
Based on the libraries: Spring Boot searches for pre-defined auto-configuration classes that correspond to those libraries.
These auto-configuration classes:
Define beans and configurations relevant to the specific libraries.
Example: Including a JPA library might trigger auto-configuration for an in-memory database and an entity manager.

Important points:

@EnableAutoConfiguration is implicitly included within the @SpringBootApplication annotation. So, if you're using @SpringBootApplication, you don't need to explicitly add @EnableAutoConfiguration.
You can customize or override the default configurations. Spring Boot allows you to define your own beans or configurations, taking precedence over the defaults.
While convenient, it's essential to understand the auto-configurations being applied. This knowledge helps you make informed decisions about customization and avoids potential unexpected behavior.

=================================================================================================


Diff between Spring, Spring MCV & SB
=======================================

========
SPRING
========
->Definition:The Spring Framework is the core framework that provides a wide range of features to build Java applications.

-> It includes support for dependency injection (DI), aspect-oriented programming (AOP), and integration with various enterprise services.

->Purpose:To provide a comprehensive programming and configuration model for enterprise applications.

->Acts as a foundation for other Spring modules, like Spring MVC and Spring Boo

->Key Features:Dependency Injection: Facilitates loose coupling between components.

->AOP: Enables cross-cutting concerns like logging, security, and transactions.

->Data Access: Simplifies interaction with databases using JDBC and ORM frameworks.

->Transaction Management: Manages transactions declaratively.

->Integration: Provides integrations with various messaging, ORM, and scheduling tools.

->Use Case:Building any type of application, from console apps to web and enterprise-grade applications.

===========
SPRING MVC
===========

->Definition:Spring MVC is a web module within the Spring Framework designed to build web applications using the Model-View-Controller (MVC) design pattern.

->Purpose:To simplify web application development by separating business logic, UI, and input control.

->Key Features:DispatcherServlet: Centralized controller that handles all HTTP requests and responses.
->Model-View-Controller Pattern:Model: Represents application data and business logic.
->View: Renders the UI using JSP, Thymeleaf, or other templating engines.
->Controller: Processes user inputs and interacts with the model.
->Form Handling: Provides built-in support for form submission and validation.
->Integration: Works seamlessly with other Spring components like Spring Security and Spring Data.

->Use Case:Developing traditional web applications where separation of concerns is critical.

===============
SPRING BOOT
==============

->Definition:Spring Boot is a framework built on top of the Spring Framework to simplify application development by minimizing boilerplate code and configurations.

->Purpose:To make Spring-based development faster and easier, especially for microservices.

->Key Features:
Auto-Configuration: Automatically configures Spring applications based on the dependencies present in the classpath.
Embedded Servers: Comes with embedded servers like Tomcat or Jetty, eliminating the need to deploy to an external server.
Opinionated Defaults: Provides sensible default configurations to get started quickly.
Starter Dependencies: Simplifies dependency management with pre-configured starter packages (e.g., spring-boot-starter-web).
Spring Boot CLI: Allows rapid prototyping of Spring applications using Groovy scripts.
Production-Ready Features: Includes monitoring, metrics, and health checks out of the box.

->Use Case:Building microservices, REST APIs, and standalone applications with minimal configuration.



Aspect	                Spring Framework	                                 Spring MVC	                               Spring Boot
Core Functionality	Provides the foundational features like DI, AOP, and transaction management.	Focused on web application development using MVC.	                          Simplifies application setup and deployment with auto-configuration.
Type	                General-purpose framework.	                                                Web-specific module of Spring Framework.	                                  Extension of Spring Framework.
Configuration    	Requires extensive manual configuration using XML or annotations.	        Requires manual configuration for web components like DispatcherServlet.	 Offers auto-configuration and opinionated defaults.
Deployment	        Requires external servers like Tomcat.	                                        Same as Spring Framework.	                                                 Comes with embedded servers like Tomcat, Jetty.
Ease of Use	        Requires more effort to configure and integrate modules.	                Moderate effort; configuration needed for web components.	                 Minimal effort; focuses on rapid development.
Use Case	       Enterprise applications needing flexibility.	                                Traditional web applications with MVC pattern.                            	Microservices, REST APIs, and quick prototypes.

==================
Example Scenarios
===================
Spring Framework:
A banking system that requires complex transaction management and integration with multiple services.
Spring MVC:
A web-based e-commerce platform with separate UI, logic, and database layers.
Spring Boot:
A microservices architecture for a social media application with multiple independent services.


====================
When to Choose What?
====================
Use Spring Framework if you need a highly customizable application with deep control over every aspect.
Use Spring MVC if your project is a traditional web application that adheres to the MVC design pattern.
Use Spring Boot if you want to quickly build standalone applications or microservices with minimal configuration.


==========
SPRINGBOOT
===========
->Spring Boot is a tool (or framework) that helps Java developers build web apps and services quickly.
->It comes with ready-made configurations so you don’t have to write a lot of setup code.
->You can create a full-blown production-grade Spring application with just a few lines.

->1. Spring Boot 1.x
Release Period: 2014–2017
Key Features:
Opinionated Defaults: Provided sensible defaults to simplify Spring application development.
Embedded Servers: Integrated servers like Tomcat and Jetty for easy deployment.
Starter Dependencies: Introduced starter POMs to manage common dependencies efficiently.
Actuator: Offered production-ready features such as health checks and metrics.

->2. Spring Boot 2.x
Release Period: 2018–2021
Key Features:
Java 8 and 9 Support: Required Java 8 as a minimum, with support for Java 9.
Reactive Programming: Introduced Spring WebFlux for building reactive applications.
Enhanced Configuration: Improved auto-configuration and property binding mechanisms.
Kotlin Support: Provided first-class support for Kotlin.
Security Enhancements: Improved security configurations and OAuth2 integration.

->3. Spring Boot 3.x
Release Period: 2022–Present
Key Features:
Java 17 Requirement: Mandated Java 17 as the minimum version.
GraalVM Native Image Support: You can now compile your app into a native .exe or .bin — which runs faster and uses less memory.Ideal for cloud, microservices, and low-resource environments.
Observability Enhancements: Integrated with Micrometer for unified metrics and tracing APIs.
Updated Dependencies: Aligned with Spring Framework 6 and other updated Spring projects.


->Spring Boot 2.x, particularly version 2.7.5, introduced several significant features and enhancements to streamline application development and improve performance

1. Java 8 and 9 Support:-
->Spring Boot 2.x set Java 8 as the minimum required version, while also supporting Java 9. 
->This shift allowed developers to leverage modern Java features such as lambda expressions, the Stream API, and the Optional class, leading to more concise and readable code

Using Lambda Expressions and Stream API:-
public class java8features{
punblic static void main(Sring[] args){

List<String> names=Arrays.asList("swapnil","rahul","niket");

names.stream().filter(name -> name.startsWith("s")).forEach(System.out::println);//output swapnil

}
}
---------------------------------------------------------------------------------------------------------------------------------------------------------
// Using Java 8's Optional and Streams
public List<String> getActiveUsernames(List<User> users) {
    return users.stream()
                .filter(User::isActive)
                .map(User::getUsername)
                .collect(Collectors.toList());
}

->Real-World Scenario: A company migrates its legacy application to Java 8 to utilize lambda expressions and the Stream API, resulting in more concise and readable code.\

2. Reactive Programming with Spring WebFlux:-

->Description: Spring WebFlux is a module introduced in Spring Boot 2.x for building reactive, non-blocking applications.
It allows handling a large number of concurrent connections with efficient resource utilization

import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;
import reactor.core.publisher.Mono;

public class UserHandler {
    public Mono<ServerResponse> getUser(ServerRequest request) {
        String userId = request.pathVariable("id");
        Mono<User> user = userService.findById(userId);
        return ServerResponse.ok().body(user, User.class);
    }
}

// Router configuration
@Bean
public RouterFunction<ServerResponse> route(UserHandler handler) {
    return RouterFunctions.route(GET("/user/{id}"), handler::getUser);
}

->Real-World Scenario: An e-commerce platform implements a real-time notification system using WebFlux to handle thousands of simultaneous user connections efficiently.


3. Enhanced Auto-Configuration and Property Binding:-
->Description: Spring Boot 2.x improved its auto-configuration capabilities, reducing the need for manual setup.
-> The introduction of the @ConfigurationProperties annotation enhanced type-safe property binding.

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "app.datasource")
public class DataSourceProperties {
    private String url;
    private String username;
    private String password;
    // getters and setters
}

// application.properties
app.datasource.url=jdbc:mysql://localhost:3306/mydb
app.datasource.username=dbuser
app.datasource.password=secret


->Real-World Scenario: A microservices architecture application uses @ConfigurationProperties to manage service-specific configurations, promoting consistency and reducing boilerplate code.



4. First-Class Kotlin Support:-

->Description: Spring Boot 2.x provided first-class support for Kotlin, allowing developers to write Spring applications in a more concise and expressive manner
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class GreetingController {
    @GetMapping("/greet")
    fun greet() = "Hello, World!"
}

->Real-World Scenario: A startup chooses Kotlin for its new application to leverage null safety and data classes, resulting in reduced development time and fewer runtime errors

5. Security Enhancements and OAuth2 Integration:-

->Description: Spring Boot 2.x enhanced its security features, simplifying the configuration process and providing comprehensive support for OAuth2, making it easier to implement authentication and authorization.

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .oauth2Login();
    }
}

->Real-World Scenario: A web application integrates with external identity providers like Google and Facebook using OAuth2, allowing users to log in with their existing accounts securely.
->These features in Spring Boot 2.x, especially in version 2.7.5, have significantly enhanced the framework's capabilities, enabling developers to build robust, efficient, and modern applications with greater ease.


=============================================
What is Reactive Programming in Spring Boot?
=============================================
->Reactive Programming is an asynchronous programming paradigm that deals with data streams and event-driven execution
->Instead of traditional blocking (synchronous) operations, reactive programming allows applications to handle multiple requests efficiently without blocking threads.

==========================
What is Spring WebFlux?
===========================
->Spring WebFlux is a reactive web framework introduced in Spring Boot 2.0 to build non-blocking, event-driven applications
->Traditional Spring MVC (Blocking Model):
Uses Thread-per-request model.
If a request involves a slow operation (e.g., database call), the thread waits (blocks) until it completes.
If multiple requests are waiting, the system can slow down or run out of threads.

->Spring WebFlux (Reactive Model):
Uses an Event Loop Model instead of creating a new thread per request.
It does not block the thread while waiting for data.
Uses Project Reactor (Mono & Flux) to handle data streams reactively.


->How Does WebFlux Work?
Mono<T> → Represents a single asynchronous result.
Flux<T> → Represents a stream of multiple results over time.


->fetching single user
@GetMapping("/user/{id}")
public Mono<User> getUser(@PathVariable String id) {
    return userRepository.findById(id); // Non-blocking call
}

->The request does not block the thread while waiting for the database to respond.
->The response is sent only when the data is ready.

-> Streaming a list of users
@GetMapping("/users")
public Flux<User> getUsers() {
    return userRepository.findAll(); // Streams users reactively
}
->Instead of waiting for all users, they are sent one by one as they become available.

=========================
Why Use Spring WebFlux?
========================
Better Performance: Uses fewer threads and efficiently handles high loads.
Non-Blocking I/O: Ideal for microservices, real-time applications, and APIs.
Scalability: Can handle more requests without increasing hardware resources.
High Throughput: Handles thousands of concurrent requests with minimal resource usage.
Non-blocking I/O: Uses event-driven architecture instead of thread-per-request.
Better Scalability: Ideal for real-time applications like chat apps, stock market updates, and streaming services.
Support for Reactive Libraries: Works with MongoDB, Redis, R2DBC, Kafka, and other reactive data sources.

==========================
When to Use Spring WebFlux?
=========================
When building high-performance APIs that need to handle thousands of concurrent users.
When using microservices that communicate asynchronously.
When working with streaming data (e.g., live dashboards, chat applications).

Reactive Types
Mono<T> → Emits 0 or 1 result (like Optional<T>)
Flux<T> → Emits multiple results (like List<T>)

->To use WebFlux, add this dependency:

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>


->Creating a Reactive REST API using Spring WebFlux
->Example: Non-blocking REST API for User Service

import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/{id}")
    public Mono<User> getUserById(@PathVariable String id) {
        return userService.findById(id); // Non-blocking DB call
    }

    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll(); // Streams data reactively
    }
}



-> Service Layer using Reactive Repository

import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public Mono<User> findById(String id) {
        return userRepository.findById(id); // Returns a Mono<User>
    }

    public Flux<User> findAll() {
        return userRepository.findAll(); // Returns a Flux<User>
    }
}

->Repository using Reactive MongoDB
import org.springframework.data.mongodb.repository.ReactiveMongoRepository;

public interface UserRepository extends ReactiveMongoRepository<User, String> {
}


->Streaming Data in Real Time
->Spring WebFlux supports Server-Sent Events (SSE) for streaming live data.

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Flux;

import java.time.Duration;

@RestController
public class StockPriceController {

    @GetMapping(value = "/stocks", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> getStockUpdates() {
        return Flux.interval(Duration.ofSeconds(1))
                   .map(i -> "Stock Price: " + (100 + i)); // Simulating stock price updates
    }
}

->Real-time scenario: This API can be used to stream live stock market prices or real-time notifications to a frontend application

==============================
Real-time Scenarios for WebFlux
===============================
-> Streaming Live Data (Stock Market, Chat, Notifications)
->Use Case: A real-time stock trading platform needs to push live stock price updates to thousands of users without overloading the server.
->Why WebFlux?
Uses Server-Sent Events (SSE) for real-time updates.
No need for polling from the client side.
Handles thousands of concurrent subscribers efficiently.

->Code Example (Live Stock Prices API):
@GetMapping(value = "/stock-price", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<StockPrice> streamStockPrices() {
    return stockService.getLiveStockPrices();
}



->Chat Application (Messaging Service)
->Use Case: A chat application requires a highly scalable system where users can send and receive messages instantly.
->Why WebFlux?

Efficient handling of thousands of chat messages.
Uses WebSockets for low-latency communication.
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.SendTo;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
public class ChatController {

    @MessageMapping("/chat")
    @SendTo("/topic/messages")
    public Mono<Message> sendMessage(Message message) {
        return Mono.just(message);
    }
}


-> IoT and Sensor Data Processing
->Use Case: A smart home system that processes data from IoT sensors (temperature, motion detection, security cameras) in real-time.
-> Why WebFlux?
Non-blocking architecture is ideal for handling massive amounts of sensor data.
Efficiently streams live IoT data to the cloud.

->Code Example (Sensor Data Stream)

@GetMapping(value = "/sensor-data", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
public Flux<SensorData> streamSensorData() {
    return sensorService.getLiveSensorData();
}


->Microservices with Asynchronous Communication
->Use Case: A banking system has microservices for handling transactions, account details, and fraud detection. 
These services communicate asynchronously for high performance.

-> Why WebFlux?
Non-blocking API ensures that microservices don’t block each other.
Uses Reactive Kafka for event-driven communication.


-> Code Example (Asynchronous Banking Service)

@GetMapping("/transactions/{id}")
public Mono<Transaction> getTransaction(@PathVariable String id) {
    return transactionService.findById(id);
}


->When to Use WebFlux vs Spring MVC?

Feature    	     Spring WebFlux (Reactive)	                     Spring MVC (Blocking)
Performance	High (Better for large concurrent users)	Moderate (Thread-per-request)
Concurrency	Handles thousands of requests efficiently	Uses one thread per request
Data Sources	Works best with NoSQL (MongoDB, Cassandra)	Works well with Relational DB (MySQL, Postgres)
Use Case	Real-time apps, microservices, streaming	Traditional web applications


================
Conclusion
===============
Spring WebFlux is a powerful framework for non-blocking, high-performance applications. 
It is widely used for: 
✔ Real-time Streaming (Stock prices, Notifications)
✔ Live Chat Applications
✔ IoT Sensor Data Processing
✔ Microservices & Asynchronous APIs

If your application does not require high concurrency, Spring MVC is still a good choice

=================================
What is High Concurrency?
==================================
->High concurrency refers to a system's ability to handle multiple requests simultaneously without performance degradation.
-> It ensures that a web application or API can serve thousands or millions of users at the same time without crashing or slowing down.

How Does Concurrency Work?
==========================
->Traditional Spring MVC (Blocking Model)
Uses one thread per request.
If 1000 users send requests, it needs 1000 threads, which consume a lot of CPU and memory.
Blocking I/O: Each request waits for the database or an external API response, making it slow under heavy load.

->Spring WebFlux (Reactive Model)
Uses a small number of threads and event loops.
Non-blocking I/O: If one request is waiting for data, the thread handles other requests.
Handles thousands of users with fewer resources (e.g., 1000 requests with just 10–20 threads).

->Example of High-Concurrency Scenario
Imagine you are building a live sports streaming app where thousands of users watch a game and get real-time score updates.

🔹 Traditional Approach (Spring MVC)
Each request for the live score starts a new thread, causing high CPU and memory usage.
If the server has 1000 threads, once all are occupied, the server becomes slow or crashes.

🔹 WebFlux Approach (Reactive Non-blocking)
Uses only a few threads to handle thousands of connections.
While waiting for the latest score, the same thread handles multiple users, ensuring fast performance.


=============
Key Takeaways
==============
✅ High concurrency = More users handled efficiently.
✅ Spring WebFlux is better for high-concurrency apps like chat apps, stock trading, and streaming.
✅ Spring MVC is suitable for low/medium traffic apps like admin dashboards or small websites.

====================================================================================================================

As u have used hibernate  how to deal with multiple databases how you are going to configure it
==================================================================================================
->This means:In a real-world project, you may need to connect your application to more than one database.
Example: One DB for user data (MySQL), another DB for orders (PostgreSQL).

->The interviewer is asking:How will you configure Hibernate & Spring Boot to connect to two databases and use them properly in the app?

Real-Time Scenario
===================
->Let’s say your application uses:MySQL for user-related data (userdb) & PostgreSQL for order-related data (orderdb)
->You need to:Connect to both databases.Use separate entity classes and repositories for each.Ensure that Hibernate knows which entity belongs to which DB

Full Real-Time Example with Explanation
=======================================
->Step 1: Add Maven Dependencies (in pom.xml)


<dependencies>
    <!-- Spring Data JPA -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>

    <!-- MySQL Driver -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

    <!-- PostgreSQL Driver -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
</dependencies>


->Step 2: Define Two Datasources in application.properties

# Primary DB - MySQL
spring.datasource.userdb.url=jdbc:mysql://localhost:3306/userdb
spring.datasource.userdb.username=root
spring.datasource.userdb.password=pass
spring.datasource.userdb.driver-class-name=com.mysql.cj.jdbc.Driver

# Secondary DB - PostgreSQL
spring.datasource.orderdb.url=jdbc:postgresql://localhost:5432/orderdb
spring.datasource.orderdb.username=postgres
spring.datasource.orderdb.password=pass
spring.datasource.orderdb.driver-class-name=org.postgresql.Driver


->Step 3: Create Entity Classes
User Entity (MySQL):
package com.example.user.entity;
import jakarta.persistence.*;
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 private String name;
    private String email;
 // Getters & Setters
}


 Order Entity (PostgreSQL):-

package com.example.order.entity;
import jakarta.persistence.*;
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 private String product;
    private Double price;
 // Getters & Setters
}


Step 4: Configure User DB (MySQL):-
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.user.repository",
    entityManagerFactoryRef = "userEntityManager",
    transactionManagerRef = "userTransactionManager"
)
public class UserDbConfig {
    @Primary
    @Bean(name = "userDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.userdb")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Primary
    @Bean(name = "userEntityManager")
    public LocalContainerEntityManagerFactoryBean userEntityManagerFactory(
            EntityManagerFactoryBuilder builder,
            @Qualifier("userDataSource") DataSource dataSource) {

        return builder
                .dataSource(dataSource)
                .packages("com.example.user.entity")
                .persistenceUnit("userPU")
                .build();
    }

    @Primary
    @Bean(name = "userTransactionManager")
    public PlatformTransactionManager transactionManager(
            @Qualifier("userEntityManager") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}

Step 5: Configure Order DB (PostgreSQL):-

@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(
    basePackages = "com.example.order.repository",
    entityManagerFactoryRef = "orderEntityManager",
    transactionManagerRef = "orderTransactionManager"
)
public class OrderDbConfig {

    @Bean(name = "orderDataSource")
    @ConfigurationProperties(prefix = "spring.datasource.orderdb")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(name = "orderEntityManager")
    public LocalContainerEntityManagerFactoryBean orderEntityManagerFactory(
            EntityManagerFactoryBuilder builder,
            @Qualifier("orderDataSource") DataSource dataSource) {

        return builder
                .dataSource(dataSource)
                .packages("com.example.order.entity")
                .persistenceUnit("orderPU")
                .build();
    }

    @Bean(name = "orderTransactionManager")
    public PlatformTransactionManager transactionManager(
            @Qualifier("orderEntityManager") EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }
}

->Step 6: Create Repositories

// UserRepository (MySQL)
package com.example.user.repository;
import com.example.user.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
public interface UserRepository extends JpaRepository<User, Long> {}


// OrderRepository (PostgreSQL)
package com.example.order.repository;
import com.example.order.entity.Order;
import org.springframework.data.jpa.repository.JpaRepository;
public interface OrderRepository extends JpaRepository<Order, Long> {}


->Step 7: Use Services or Controllers

@RestController
public class TestController {

    @Autowired
    private UserRepository userRepo;

    @Autowired
    private OrderRepository orderRepo;

    @GetMapping("/save")
    public String saveBoth() {
        userRepo.save(new User(null, "Swapnil", "swapnil@gmail.com"));
        orderRepo.save(new Order(null, "Keyboard", 1200.0));
        return "Saved to both databases!";
    }
}


Summary
===========
Topic	         Description
🧠 Question	How do you use Hibernate with multiple databases?
💼 Scenario	One DB for user info, another for orders
⚙️ Config	2 data sources, 2 entity managers, 2 transaction managers
🧾 Result	Both DBs are used in same Spring Boot app independently


Explanations:-
==============
@Configuration:-  Marks this class as a Spring configuration class.
@EnableTransactionManagement :-Enables transaction support for this database.
@EnableJpaRepositories(...):Tells Spring to scan com.example.user.repository for JPA Repositories.Links them to the custom EntityManager and TransactionManager defined below.

userDataSource:-Reads DB config from application.properties (spring.datasource.userdb.*).Creates a DataSource (DB connection pool)
userEntityManagerFactory:-Builds the EntityManagerFactory for Hibernate.Scans com.example.user.entity for entity classes.Uses userDataSource
userTransactionManager:-Manages DB transactions (commit/rollback) for the userdb
@Primary:Indicates this is the default bean when multiple data sources are present.

his config tells Spring:“Use this MySQL/PostgreSQL DB (userdb) for all repositories under com.example.user.repository, using the entity classes from com.example.user.entity.”

----------------------------------------------------------------------------------------------------------------------------------------------------
Comparable & Comparator
=======================
->In Java, Comparable and Comparator are two interfaces used to sort objects. 
->Both are part of java.util and java.lang packages and help define custom sorting logic.

What is Comparable?
===================
->Used to define the natural ordering of objects.
->The class itself implements the Comparable interface.
->Has only one method:public int compareTo(T o);
->Yes. It is a functional interface (since it has only one abstract method).

Syntax
=======
public class Student implements Comparable<Student> {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.id - other.id;  // sort by id in ascending order
    }
}
 Real-Time Example: Using Comparable
======================================
import java.util.*;
class Student implements Comparable<Student> {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public int compareTo(Student other) {
        return this.id - other.id; // ascending order
    }

    @Override
    public String toString() {
        return id + " " + name;
    }
}
public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "John"));
        list.add(new Student(1, "Alice"));
        list.add(new Student(2, "Bob"));

        Collections.sort(list);  // uses compareTo

        for (Student s : list) {
            System.out.println(s);
        }
    }
}

Op:-1 Alice
2 Bob
3 John

What is Comparator?
====================
->Used to define custom ordering externally (i.e., separate from the class).
->Useful when you want multiple sort criteria.
->Has two main methods:int compare(T o1, T o2);
boolean equals(Object obj); // rarely overridden
->Yes. It is also a functional interface (because of the compare method).

Syntax
=======
class Student {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

Real-Time Example: Using Comparator
====================================
import java.util.*;

class Student {
    int id;
    String name;

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return id + " " + name;
    }
}

// Comparator to sort by name
class NameComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name);
    }
}

// Comparator to sort by ID
class IdComparator implements Comparator<Student> {
    public int compare(Student s1, Student s2) {
        return s1.id - s2.id;
    }
}

public class Main {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(3, "John"));
        list.add(new Student(1, "Alice"));
        list.add(new Student(2, "Bob"));

        // Sort by Name
        Collections.sort(list, new NameComparator());
        System.out.println("Sorted by Name:");
        for (Student s : list) {
            System.out.println(s);
        }

        // Sort by ID
        Collections.sort(list, new IdComparator());
        System.out.println("\nSorted by ID:");
        for (Student s : list) {
            System.out.println(s);
        }
    }
}

Op:-Sorted by Name:
1 Alice
2 Bob
3 John

Sorted by ID:
1 Alice
2 Bob
3 John


Comparable vs Comparator
=========================
Feature   	                  Comparable	          Comparator
Package	                           java.lang	        java.util
Method	                           compareTo(T o)	        compare(T o1, T o2)
Sorting logic                  	In the class itself	In separate class
Affects original class?	              Yes	            No
Can define multiple sorts?	❌ Only one	       ✅ Many comparators
Functional Interface?	          ✅ Yes	               ✅ Yes

Summary in Simple Words:
==========================
->Use Comparable if sorting logic is default/natural and will be always same (e.g., sort by ID).
->Use Comparator when you need to sort differently in different places (e.g., by name, by date).

=================================================================================================================

StringBuffer & StringBuilder
=============================
->StringBuffer and StringBuilder is crucial in Java, especially when working with mutable strings and performance-sensitive string operations.
->Before we dive into StringBuffer and StringBuilder, remember:

String str = "Hello";
str += " World";
->The above code seems simple, but under the hood, every time you modify a String, a new object is created (because String is immutable). 
This can be a performance issue, especially in loops or large text manipulations

StringBuffer?
==============
->It is a mutable sequence of characters.
->Belongs to java.lang package.
->Thread-safe (i.e., synchronized) — suitable for multi-threaded environments.
->Slower than StringBuilder due to synchronization overhead.

StringBuffer sb = new StringBuffer("Hello");
sb.append(" World");
System.out.println(sb);  // Hello World

StringBuilder?
=============
->Also a mutable sequence of characters.
->Introduced in Java 5.
->Not thread-safe (i.e., not synchronized).
->Faster than StringBuffer — suitable for single-threaded environments.

StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb);  // Hello World

Summary Table: String vs StringBuffer vs StringBuilder
=======================================================
Feature	                 String	                    StringBuffer	               StringBuilder
Mutability	    ❌ Immutable	                    ✅ Mutable	                        ✅ Mutable
Thread-safe	    ✔ Yes (immutable)	            ✔ Yes (synchronized)	          ❌ No
Performance	    🚫 Slow (creates new objects)    ⚠ Slower (due to thread safety)	✅ Fastest
Use case	     Constant values	            Multi-threaded string ops	       Fast single-thread string ops


Realtime Example 1: Using StringBuilder in a Loop
===================================================
Imagine you're building a large JSON string or HTML content dynamically.

public class Example1 {
    public static void main(String[] args) {
        StringBuilder html = new StringBuilder();

        html.append("<html>");
        html.append("<body>");
        html.append("<h1>Welcome, User!</h1>");
        html.append("</body>");
        html.append("</html>");

        System.out.println(html.toString());
    }
}

->Why not use String? Because each + would create a new string object → memory waste & slower performance.

Realtime Example 2: Using StringBuffer in a Multi-threaded Environment
==========================================================================
public class Example2 {
    static StringBuffer buffer = new StringBuffer();

    public static void main(String[] args) {
        Thread t1 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                buffer.append("A");
            }
        });

        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                buffer.append("B");
            }
        });

        t1.start();
        t2.start();

        try {
            t1.join();
            t2.join();
        } catch (InterruptedException e) {}

        System.out.println(buffer.toString()); // e.g., AABABABABB
    }
}

-> Why use StringBuffer? Because it's synchronized — safe even when two threads modify it concurrently.


When to Use Each?
==================
Scenario	                                                            Use
You need to build strings in a loop (single-threaded)	                 StringBuilder
You're in a multi-threaded environment	                                 StringBuffer
Strings are not going to change	                                         String
Heavy text manipulation (e.g. templates, logs, XML/JSON creation)	 StringBuilder or StringBuffer

Summary in Simple Words:
==========================
String → Use for constant text (immutable, safe but slow when changed).
StringBuilder → Use for high-performance text building (single-threaded).
StringBuffer → Use for safe text building in multi-threaded programs.
=======================================================================


What is @Conditional in Spring Boot?
=======================================

->The @Conditional annotation is used to conditionally create or load a Spring bean or configuration only if a specific condition is true.

->In simple terms:“Load this class or bean only if a certain condition is satisfied.”

Why use it?
=============
To make your application dynamic and configurable, for example:

Load beans only when a certain property is enabled.

Load configs only if a class is present.

Load logic based on OS or environment.


 Real-Time Example 1: Feature Toggle (Property-based)
======================================================
->You want to enable or disable a feature using a flag in application.properties

->Define a condition class:

public class FeatureEnabledCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String feature = context.getEnvironment().getProperty("my.feature.enabled");
        return "true".equalsIgnoreCase(feature);
    }
}



->Use @Conditional on your bean:

@Configuration
public class MyFeatureConfig {

    @Bean
    @Conditional(FeatureEnabledCondition.class)
    public MyService myService() {
        return new MyService();
    }
}

->In application.properties:my.feature.enabled=true


->If the property is set to true, Spring will create myService bean.If it's false or not set, the bean will not be created.



Real-Time Example 2: Load Bean Only on Windows OS
===================================================

public class OnWindowsCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return context.getEnvironment().getProperty("os.name").toLowerCase().contains("windows");
    }
}


@Bean
@Conditional(OnWindowsCondition.class)
public FilePathConfig windowsPathConfig() {
    return new FilePathConfig("C:\\temp\\");
}

->Useful when you want to use different file paths/configs for Windows and Linux.



Real-Time Example 3: Only Load a Bean If Another Bean is Missing
==================================================================

@Bean
@ConditionalOnMissingBean(MyService.class)
public MyService defaultMyService() {
    return new MyService(); // loaded only if MyService is not defined elsewhere
}


Annotation	                        Use Case Example
@ConditionalOnProperty	         Based on property value in application.properties
@ConditionalOnClass	         Load bean if a specific class is in classpath
@ConditionalOnMissingBean	 Load only if bean not already defined
@ConditionalOnBean	         Load only if another bean is present

Summary (In simple words):
=========================
Concept	What It Means
@Conditional	       Create beans/configs only when certain condition is satisfied
Benefit	               Makes your Spring Boot app dynamic, configurable, and environment-aware
Used When	       Feature toggles, OS checks, optional dependencies, etc.
==========================================


What is a JIT Compiler?
===========================
JIT stands for Just-In-Time compiler.
It is a part of the Java Virtual Machine (JVM) that improves the performance of Java applications by compiling bytecode to native machine code at runtime.


Simple Explanation:
==================
When you write and compile Java code:
Your .java files are compiled by the Java Compiler (javac) into bytecode (.class files).
This bytecode runs on the JVM, which is platform-independent.
The JVM uses the JIT compiler to convert frequently-used (hot) bytecode into native machine code, so your CPU can execute it directly — much faster than interpreting it every time.

Without JIT:
==============
JVM interprets bytecode line by line, which is slower.

With JIT:
=============
JVM compiles bytecode to native code once, and reuses it, boosting speed.

How JIT Works (Step-by-step):
==============================
JVM starts executing bytecode line-by-line using an interpreter.
JIT monitors which methods are called frequently (hot methods).
When a method becomes hot, JIT compiles it into native machine code.
The compiled code is cached, so next time it's needed, JVM uses the compiled code directly.
Performance improves significantly over time.

Real-Time Analogy:
=====================
Think of JIT like this:
You cook instant noodles (bytecode) by reading the recipe every time (interpreting) — slow!
But once you memorize the recipe (JIT compiles it), you can cook much faster without reading — fast!

Types of JIT Compilers in JVM:
=================================
Type	Description
Client Compiler (C1)	Optimized for quick startup, used in desktop apps.
Server Compiler (C2)	Optimized for long-running performance, used in server-side apps.

Modern JVMs use Tiered Compilation: combination of both C1 and C2.

Benefits of JIT:
===================
Faster execution after warm-up.
Optimizes code during runtime.
Helps remove unused code paths (dead code elimination).
Performs method inlining, loop unrolling, and other optimizations.

Limitations:
=============
Small delay during warm-up (first few executions are slower).
Uses more memory and CPU initially.

📌 Summary:
=============
Feature	                                    Description
JIT Compiler	                 Part of JVM that compiles bytecode to native machine code at runtime
Purpose	                         Improve performance of Java applications
Trigger                   	Frequently executed methods (hot code)
Benefit	                        Faster execution, optimized performance

----------------------------------------------------------------------------------------

Difference between Hashmap & Hashtable
========================================

Feature                    	HashMap         	                            Hashtable
Thread Safety	        ❌ Not thread-safe	                         ✅ Thread-safe (synchronized methods)
Performance	        Faster (no locking)	                         Slower due to synchronization
Null Keys/Values	Allows one null key and multiple null values	 ❌ Doesn’t allow any null key or value
Introduced In	        JDK 1.2	                                         JDK 1.0
Use Case	        When synchronization is not needed	         When thread safety is required (legacy systems)
Fail-Fast Iterator	Yes	                                         No (enumeration, not iterator)


Real-Time Example
=================
Let’s simulate both in a Spring Boot style Java class.
import java.util.*;
public class MapComparison {
 public static void main(String[] args) {

        // Using HashMap
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "Swapnil");
        hashMap.put("role", "Developer");
        hashMap.put(null, "Allowed Null Key");
        hashMap.put("location", null); // Allowed

        System.out.println("HashMap: " + hashMap);

        // Using Hashtable
        Map<String, String> hashtable = new Hashtable<>();
        hashtable.put("name", "Swapnil");
        hashtable.put("role", "Developer");

        // hashtable.put(null, "No null key"); ❌ throws NullPointerException
        // hashtable.put("location", null); ❌ throws NullPointerException

        System.out.println("Hashtable: " + hashtable);
    }
}

 Real-Time Use Case
=====================
Scenario	                                                      Which to Use
Multi-threaded application that needs thread safety	Use ConcurrentHashMap (preferred over Hashtable)
Single-threaded environment or internal caching	        Use HashMap (faster and cleaner)

Interview-Ready Answer
========================

HashMap is non-synchronized and not thread-safe, making it faster in single-threaded environments. It allows one null key and multiple null values.
On the other hand, Hashtable is synchronized, meaning it is thread-safe but slower. 
It doesn’t allow any null keys or values. In real-time, I prefer HashMap with external synchronization or ConcurrentHashMap for thread-safe operations in modern applications.

->What happens if you insert duplicate keys in HashMap?
A: The new value replaces the old one. HashMap only allows unique keys.

->How does HashMap work internally?
Uses hashCode() and equals() methods.
Stores entries in buckets (array of nodes).
If multiple keys have the same hash, it handles collision using:
Linked list (Java 7 and below)
Balanced tree (Red-Black Tree) when bucket size > 8 (Java 8+)


->Why is HashMap not thread-safe?
A: Because multiple threads can modify the internal structure (like resizing or put), leading to inconsistencies or infinite loops.

-. Can a HashMap key be null?
A: Yes, only one null key is allowed.

 Difference between ConcurrentHashMap and Hashtable?
======================================================
Feature	             ConcurrentHashMap	        Hashtable
Locking	         Fine-grained (bucket-level)	Method-level
Null support	❌ No null key/value	        ❌ No null key/value
Performance	Better in concurrency	        Slower
Fail-Safe	Weakly consistent	        No iterator


->Which Map is preferred in multi-threaded environment?
Answer: ConcurrentHashMap — because it provides better concurrency using bucket-level locking, unlike Hashtable which locks the entire method.
==================================================================================================================================================================

What is Marker interface & Functional Interface
================================================
->A Marker Interface is a special type of interface that does not contain any methods or fields.
->Its purpose is to "mark" a class so that the JVM or a framework can recognize it and treat it differently at runtime.
->Think of it as a flag or tag — you're not telling the compiler how something should be done, just indicating that this class belongs to a specific category.

Popular Built-in Marker Interfaces:
====================================
Interface	Purpose
Serializable	Marks a class for object serialization
Cloneable	Marks a class to allow field-by-field cloning
Remote	        Used in RMI to indicate a class can be called remotely

Real-Time Example: Serialization
================================
->You want to send Employee objects over a network or save them into a file.

->Without Serializable:
class Employee {
    int id;
    String name;
}

->If you try to serialize this:
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("emp.ser"));
Employee emp = new Employee();
oos.writeObject(emp);  // ❌ Throws NotSerializableException

->With Serializable Marker Interface:
import java.io.Serializable;

class Employee implements Serializable {
    int id;
    String name;

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

->Now it works:
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("emp.ser"));
Employee emp = new Employee(101, "Swapnil");
oos.writeObject(emp);  // ✅ Success

->This is because ObjectOutputStream internally checks:

if (!(obj instanceof Serializable)) {
    throw new NotSerializableException(obj.getClass().getName());
}

->So Serializable acts as a marker to enable serialization.

Real-Time Use Case in Frameworks (Spring)
===========================================
->Spring uses marker interfaces and annotations together.
->Example: org.springframework.web.context.WebApplicationContext
Spring checks if a bean implements certain marker interfaces like:
InitializingBean
DisposableBean

->Framework does something special:
if (bean instanceof InitializingBean) {
    ((InitializingBean) bean).afterPropertiesSet();
}

Advantages of Marker Interface
================================
Metadata at Runtime: Allows JVM/framework to identify special classes.
Clean & Lightweight: No implementation burden.
Backward Compatibility: Older codebases widely use it.
Supports Type Safety: You can use instanceof or generic bounds.

Disadvantages of Marker Interface
===================================
Cannot define behavior — no method, just tagging.
Not flexible — can’t carry values or configurations.
Hard to scale — if you need additional logic, you have to create new interfaces.

 Marker Interface vs Annotation
===============================
Aspect	                      Marker Interface	                                     Annotation
intoroduced                   java1.0                                           java 5
syntax                       interface                                          @interface
Methods	                     No	                                       Can have elements (fields)
Inheritance	             Single	                               Multiple via meta-annotations
Runtime Processing	     Via instanceof or reflection	                   Via reflection
Preferred Today?	     ❌ Legacy or not preferred any more	                ✅ Preferred (since Java 5+)
Can be retained at runtime?   yes                                              Customizable via @Retention


Modern Alternative Using Annotation
===================================
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MySerializable {}

->Usage:
@MySerializable
class Employee {
    int id;
    String name;
}


->Frameworks like Spring or Jackson use annotations like:
@Component
@Entity
@JsonIgnore
These annotations carry metadata and behavior, making them more powerful.


Where Marker Interface is Used in Real Projects
===============================================
->Serializable (in Banking/Finance Systems)
Used when storing customer details, transactions, or account data temporarily or transferring over the network.

E.g., caching user session objects in Redis after converting them to byte stream.

-> Cloneable (in Prototyping Patterns)
Used to create copies of objects without invoking constructors, often used in design patterns like Prototype.

->3. Custom Marker Interface in Security

public interface Auditable {}  // Marker interface

public class Invoice implements Auditable {
    // fields, methods...
}

->Later, in a Spring AOP aspect or logging interceptor:


if (object instanceof Auditable) {
    logAction("Audit Log for: " + object);
}
-> This pattern is used to mark sensitive or traceable entities in audit logs or security checks.


Tricky Interview Questions
===========================
->Can a marker interface have methods?
No. By definition, it must be empty. If you add a method, it's no longer a marker interface.

-> Why use a marker interface instead of a boolean field or annotation?
Marker interfaces allow type-based checks using instanceof.
They integrate well with OOP features like polymorphism.
Annotations are modern and flexible but marker interfaces are still found in legacy systems and some frameworks.

->Can we create our own marker interface?
Yes! You can define any interface with no methods and use it in custom frameworks or logic.

-> How is the marker interface different from tagging via annotations?
Marker interface = compile-time or runtime type check (instanceof).
Annotation = metadata-based processing using reflection.

Summary:
==========
Feature	                            Marker Interface
What is it?	                  Empty interface (no methods)
Purpose	                           Used to tag or mark a class
JVM Usage	                   Special behavior for marked classes
Real Examples	                  Serializable, Cloneable, Remote
Use in Projects	                  Serialization, cloning, security, AOP
Preferred Today?	          Less now, mostly replaced by annotations


 Interview Tip / Summary Answer:
==================================
A marker interface is an empty interface that provides metadata to the JVM or frameworks to treat the class differently. 
For example, implementing Serializable tells JVM that the object can be serialized. 
While it's simple and type-safe, modern Java development prefers annotations for more flexibility.

->A Functional Interface is an interface that contains exactly one abstract method.
->It is used primarily to enable Lambda Expressions and Method References, introduced in Java 8 to promote functional programming.
->Even though functional interfaces can have default or static methods, they must have only one abstract method.

@FunctionalInterface
->This is optional but recommended.
->It forces the compiler to verify that the interface follows the functional interface rule (only one abstract method).

Common Functional Interfaces in Java:
======================================
Interface	Method Signature	     Purpose
Runnable	void run()	        Used to run a thread
Callable<V>	V call()	        Similar to Runnable, but returns result
Function<T,R>	R apply(T t)	        Takes one argument, returns a result
Predicate<T>	boolean test(T t)	Tests a condition
Consumer<T>	void accept(T t)	Takes input, returns nothing
Supplier<T>	T get()	                Produces a result
Comparator<T>	int compare(T o1, T o2)	Compares two objects

 Real-Time Use Case (Custom Functional Interface)
=====================================================
->You want to pass a block of logic (like a callback or handler) without creating anonymous classes.
->Custom Functional Interface:
@FunctionalInterface
interface MyPrinter {
    void print(String msg);
}


->Using Lambda Expression:
public class FunctionalExample {
    public static void main(String[] args) {
        MyPrinter printer = message -> System.out.println("Printing: " + message);
        printer.print("Hello Interview!");
    }
}

->op:-Printing: Hello Interview!
->Here, we pass behavior (printing) using a lambda, without implementing the full interface.

Real-Time Use Case in Enterprise (Stream API)
===============================================
->Filtering names starting with "S" from a list.
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class PredicateDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Swapnil", "Amit", "Suresh", "Neha");

        Predicate<String> startsWithS = name -> name.startsWith("S");

        List<String> filtered = names.stream()
                                     .filter(startsWithS)
                                     .collect(Collectors.toList());

        System.out.println("Filtered names: " + filtered);
    }
}

->op:-Filtered names: [Swapnil, Suresh]

Real-Time Use Case in Spring Boot
==================================
->Using Function<T, R> in functional programming pipelines or microservices.

@Bean
public Function<String, String> toUpperCase() {
    return input -> input.toUpperCase();
}


->In Spring Cloud Function, this function can be exposed as a REST endpoint.
->Used in serverless deployments like AWS Lambda functions.

Advantages of Functional Interfaces
===================================
Advantage	                          Description
✅ Concise Code                     	Enables use of Lambdas to replace verbose anonymous classes
✅ Functional Style	                Promotes functional programming and immutability
✅ Easy to Use in Streams	        Used heavily in filtering, mapping, reducing
✅ Reusability	                        Can define behavior and pass it as a parameter
✅ Better Readability	                Focus is on “what to do” instead of “how to do”

Disadvantages
==================
Disadvantage	                      Explanation
❌ Only One Abstract Method	Limits the interface to single responsibility
❌ Can Be Misused	        Adding multiple abstract methods accidentally can break functional behavior
❌ Debugging	                Lambda errors can be harder to trace for beginners


Interview-Tricky Questions
============================
->Can a functional interface have default or static methods?
 Yes, it can have any number of default and static methods, but only one abstract method.

->Is @FunctionalInterface mandatory?
 No, it’s not mandatory, but highly recommended.
 It helps the compiler enforce the rule of "only one abstract method".

->Can a functional interface extend another interface?
Yes, as long as the combined interfaces don't add more than one abstract method.

interface A {
    void test();
}

@FunctionalInterface
interface B extends A {
    // Still valid
}

->What happens if we add two abstract methods in a functional interface?
It will fail at compile time if annotated with @FunctionalInterface.

->How are functional interfaces used in Java 8 collections?

List<String> list = Arrays.asList("a", "b", "c");
list.forEach(item -> System.out.println(item)); // Uses Consumer<T>


What is the difference between Predicate and Function?
======================================================
Feature	               Predicate<T>	        Function<T, R>
Purpose	              Test condition	        Transform value
Method	              boolean test(T t)	        R apply(T t)
Example Use	      filter() in streams	map() in streams

Summary
=========
Feature	               Functional Interface
Abstract Methods      Only one
Java Version	      Introduced in Java 8
Usage	             Lambdas, Method References, Streams
Real-time Usage	     Spring Cloud Function, Stream API, AWS Lambda
Annotation	     @FunctionalInterface
===========================================================================================================================

What are indexes.Clustered & Non clustered indexes
===================================================
->An index in SQL is a data structure that improves the speed of data retrieval operations on a table at the cost of additional space and slower writes (INSERT/UPDATE/DELETE).
->It works similarly to an index in a book — instead of scanning every page (row), the database uses the index to jump directly to the relevant data.

Why Use Indexes?
==================
Speeds up SELECT queries
Optimizes JOIN operations
Improves WHERE, ORDER BY, and GROUP BY performance

 Clustered Index
==================
->A clustered index determines the physical order of data in the table.
->A table can have only one clustered index.
->By default, the primary key is a clustered index (unless specified otherwise).

->Think of clustered index as the actual sorted data.

->Suppose you have an Employee table:
CREATE TABLE Employee (
  emp_id INT PRIMARY KEY,
  name VARCHAR(50),
  department VARCHAR(50),
  salary INT
);

->Here, emp_id is the primary key, so it's the clustered index. The table’s data is physically stored in the order of emp_id.
->Query Optimization Example:SELECT * FROM Employee WHERE emp_id = 101;
->SELECT * FROM Employee WHERE emp_id = 101;
->Because emp_id is clustered, this is very fast — the DB directly jumps to the data.

Non-Clustered Index
======================

->A non-clustered index creates a separate structure from the actual data.
->It contains pointers (row locators) to the actual data rows.
->A table can have multiple non-clustered indexes.

->Think of non-clustered index as a lookup table pointing to the actual data.

->Let’s say we often search employees by department:
CREATE NONCLUSTERED INDEX idx_department ON Employee(department);


->Query Optimization Example:SELECT name FROM Employee WHERE department = 'HR';

->Now, instead of scanning the entire table, SQL uses the non-clustered index on department to quickly find all HR employees and fetch their names.


Difference Between Clustered and Non-Clustered Index
=====================================================
Feature	                              Clustered Index	                            Non-Clustered Index
Data Storage	                Data is physically sorted	                Index is separate from data
Number per Table	        Only one	                                Many (up to 999 in SQL Server)
Access Time	                Faster for range/primary key queries	        Slightly slower (extra lookup step)
Default on	                Primary Key	                                Optional on any column
Pointer Structure	        Not needed (data is inline)	                Points to row locators in clustered index


Real-Time Use Case (Project-Level)
===================================

->Scenario:You’re working on a Job Portal. You have a JobApplications table:

CREATE TABLE JobApplications (
  application_id INT PRIMARY KEY,
  job_id INT,
  applicant_id INT,
  status VARCHAR(20),
  applied_date DATE
);


->Clustered Index:Primary Key (application_id) is clustered → Most queries use it to uniquely identify a row.
->Non-Clustered Index Use Cases:
You often filter or sort by applied_date:

CREATE NONCLUSTERED INDEX idx_applied_date ON JobApplications(applied_date);

Search/filter by status (e.g., ‘Pending’):

CREATE NONCLUSTERED INDEX idx_status ON JobApplications(status);


Best Practices for Indexing
==============================
Practice	                      Description
⚠ Don't over-index	        Too many indexes = slower writes
📊 Use indexing on filtering columns (WHERE)	
🚦 Monitor with EXPLAIN PLAN	Check if query is using index
🔁 Rebuild indexes	Periodically rebuild fragmented indexes
🔍 Covering Index	Create indexes that include all columns in SELECT to avoid accessing the table at all


EXPLAIN PLAN (Example)
========================

EXPLAIN SELECT name FROM Employee WHERE department = 'IT';

->This tells you whether the query is using the index or doing a full scan.

Summary
============
Index Type	                                   Use When
Clustered Index	         On primary key or when a column is used frequently for sorting and ranges
Non-Clustered Index	On search, filter, or join columns (e.g., email, status, date)
-----------------------------------------------------------------------------------------------------------

What is JWT.What it consist
============================
->JWT (JSON Web Token) is a compact, URL-safe token format used to securely transmit information between two parties (usually client and server) as a JSON object.
->It is widely used for authentication and authorization in modern RESTful APIs.

Why JWT is used?
================
Stateless authentication (no session on server)
Self-contained (contains user info + permissions)
Compact and can be passed via HTTP Headers
Secured using digital signature (HMAC or RSA)

JWT Structure
===============
JWT has three parts separated by dots (.):
Header.Payload.Signature

1. Header
=========
{
  "alg": "HS256",
  "typ": "JWT"
}

alg: Algorithm used to sign the token
typ: Token type

2. Payload
============
Contains claims: statements about the user.
{
  "sub": "swapnil",
  "role": "admin",
  "iat": 1710092911,
  "exp": 1710096511
}

sub: subject (usually username)
role: custom claim (e.g., user role)
iat: issued at
exp: expiration time

3. Signature
==============
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

->Signature ensures the token was not tampered with.

Real-Time Example: Spring Boot JWT Authentication
==================================================
->Step 1: Add Dependencies (in pom.xml)
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>


-> Step 2: Create JWT Utility Class
import io.jsonwebtoken.*;
import org.springframework.stereotype.Component;
import java.util.Date;

@Component
public class JwtUtil {
    private final String SECRET_KEY = "mysecretkey";

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .claim("role", "USER")
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60)) // 1 hour
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }

    public boolean validateToken(String token, String username) {
        return extractUsername(token).equals(username) && !isTokenExpired(token);
    }

    private boolean isTokenExpired(String token) {
        Date expiration = Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody()
                .getExpiration();
        return expiration.before(new Date());
    }
}


->Step 3: Use JWT in Controller
@RestController
@RequestMapping("/api")
public class AuthController {

    @Autowired
    private JwtUtil jwtUtil;

    @PostMapping("/login")
    public ResponseEntity<String> login(@RequestBody AuthRequest authRequest) {
        // dummy check
        if ("swapnil".equals(authRequest.getUsername()) && "password".equals(authRequest.getPassword())) {
            String token = jwtUtil.generateToken(authRequest.getUsername());
            return ResponseEntity.ok(token);
        } else {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }
    }
}

->Headers in Postman
Authorization: Bearer <token>

JWT in Real-Time Project Use Case
==================================
-> Used for user login. On successful login:
Server sends JWT token to client
Client stores it (usually in localStorage)
Client sends JWT in Authorization header for each request
-> Used in Microservices for service-to-service authentication (using token validation)
-> Secure APIs without maintaining session on server → stateless.

Advantages of JWT:
====================
Stateless (No session needed on server)
Portable & Compact
Self-contained
Can be easily used across different microservices

❌ Disadvantages:
====================
Cannot be invalidated easily (once issued)
Large payload size if not managed properly
Token expiration must be managed correctly

 Tricky Interview Questions:
============================
      Question	                                                     Answer
Can JWT be tampered with?	                 No, signature is validated on server using secret key.
Where do you store JWT on client side?	         LocalStorage or HttpOnly cookies (for security).
How to invalidate JWT before expiration?	 Implement blacklist on server or rotate secrets.
Is JWT secure?	                                 Yes, if HTTPS + strong secret + short expiration are used.


=======================================================================================================================================================
==================================
What is an Abstract Class in Java?
==================================
->An abstract class is a class that cannot be instantiated (i.e., you cannot create objects of it directly).
->It is meant to be inherited by other classes and can contain both:
Abstract methods (methods without a body)

Concrete methods (fully defined methods with logic)
->It is defined using the keyword abstract.

abstract class Vehicle{
abstract void start();
void stop(){
sop("Vehicle Stopped")
}
}

Why and When Do We Use Abstract Classes?
=======================================
To provide common behavior across different classes.
To define a template or contract that subclasses must follow.
To enforce partial implementation: Some logic is common and can be written in abstract class, rest to be implemented by subclasses.

Rules for Abstract Class in Java
=================================
Feature	Abstract                Class
Can have abstract methods	✅ Yes
Can have concrete methods	✅ Yes
Can have constructors	        ✅ Yes
Can have instance variables	✅ Yes
Can be extended (inherited)	✅ Yes
Can be instantiated	        ❌ No


Real-Time Use Case – Transport Booking App
============================================
->Suppose you're developing a transport booking system (like Uber/Ola). You have different types of vehicles like Car, Bike, and Bus.
->Instead of repeating common logic (e.g., stop() or getDetails()), you can define them in an abstract class.

 Real-World Code Example (Transport System)
===========================================
-> Step 1: Define Abstract Class Vehicle

abstract class Vehicle{
String registrationNumber;
String owner;

Vehicle(String registrationNumber,String owner){
this.registrationNumber = registrationNumber;
        this.owner = owner;
}

//abstract method(must be implemented by child)
abstract void start();

//concrete method
void stop(){
System.out.println("Vehicle stopped");
}

void getDetails(){
 System.out.println("Reg No: " + registrationNumber + ", Owner: " + owner);

}
}


-> Step 2: Define Subclass Car

class Car extends vehicle{
Car(String regNo, String owner) {
        super(regNo, owner);

@Override
    void start() {
        System.out.println("Car started with key ignition");

}
}

->Step 3: Define Subclass Bike

class Bike extends Vehicle {
    Bike(String regNo, String owner) {
        super(regNo, owner);
    }

    @Override
    void start() {
        System.out.println("Bike started with self-start");
    }
}


->Step 4: Main Class (Usage)

public class MainApp {
    public static void main(String[] args) {
        Vehicle car = new Car("MH12AB1234", "Ravi");
        Vehicle bike = new Bike("MH14CD5678", "Amit");

        car.getDetails();
        car.start();
        car.stop();

        System.out.println();

        bike.getDetails();
        bike.start();
        bike.stop();
    }
}

Op:-Reg No: MH12AB1234, Owner: Ravi
Car started with key ignition
Vehicle stopped

Reg No: MH14CD5678, Owner: Amit
Bike started with self-start
Vehicle stopped


Real-Time Scenarios Where Abstract Class is Used
=================================================

  Use Case	                         Abstract Class Role
Banking System	                  Account as abstract base class for Savings, Current
E-commerce	                  PaymentGateway as abstract class for RazorPay, PayPal, etc.
Transport/Booking Systems	  Vehicle as abstract class for Car, Bike, Bus
Notification Services	          NotificationService as abstract class for EmailNotification, SMSNotification
UI Component Libraries	          Component class as base for Button, Textbox, Dropdown

When to Prefer Abstract Class over Interface?
================================================
Use abstract class when:
You need to share common code across all child classes.
You want to maintain state (i.e., instance variables).
You expect future versions to have more functionality.

Final Thought
=============
Abstract classes help you design more structured, reusable, and extensible code in large applications.
They are ideal when you want to enforce behavior and provide default logic at the same time.

-------------------------------------------------------------------------------------------------------------------------------------------------
 Abstract Class vs Interface in Java
========================================


->Understanding the difference between an abstract class and an interface is critical in Java for designing clean and scalable code.

Feature	                                  Abstract Class	                               Interface
Keyword Used	                             abstract	                                      interface
Methods	                                Can have abstract and concrete methods	  All methods are abstract (Java 7); From Java 8, can have default, static, and private methods
Constructors                             	✅ Yes	                                           ❌ No
Fields (Variables)	                Can have instance variables	          Only public static final constants
Access Modifiers	                Can be private, protected, or public	  All methods are public by default
Multiple Inheritance	                ❌ No (single class inheritance)	          ✅ Yes (a class can implement multiple interfaces)
Use Case	                        For objects with shared code/logic	  For defining a contract without implementation
Instantiation	                        ❌ Cannot instantiate	                  ❌ Cannot instantiate


When to Use What?
====================
Use abstract class when:
You want to share common code among related classes.
You need constructors, instance variables, or access control.

Use interface when:
===================
You want to define a capability/behavior (like Comparable, Serializable).
You need multiple inheritance of types.
You want to define a pure contract for implementing classes.

Real-Time Example: Payment Gateway System
============================================
Let’s implement both abstract class and interface for a payment system.
 Using Abstract Class
=====================
->Abstract Base Class

abstract class PaymentGateway{
String merchantId;

PaymentGateway(String merchantId){
this.merchantId=merchantId;
}

abstract void pay(double amount);// to be implemented by subclass

void printReceipt(){
System.out.println("Receipt printed for Merchant ID: " + merchantId);
}
}

->Subclass: RazorPay

class RazorPay extends Paymentgateway{

RazorPay(String merchantId) {
        super(merchantId);
    }

@override
void pay(double amount);
System.out.println("Paid ₹" + amount + " via RazorPay");
}

->Main Class:

public class PaymentApp {
    public static void main(String[] args) {
        PaymentGateway payment = new RazorPay("RAZ12345");
        payment.pay(1000);
        payment.printReceipt();
    }
}

->Op:Paid ₹1000.0 via RazorPay
Receipt printed for Merchant ID: RAZ12345


Using Interface
===============

-> Interface:

interface IPaymentGateway {
    void pay(double amount); // abstract by default

    default void printReceipt() {
        System.out.println("Receipt printed (interface)");
    }
}


-> Implementing Class:
class PayPal implements IPaymentGateway {

    @Override
    public void pay(double amount) {
        System.out.println("Paid ₹" + amount + " via PayPal");
    }
}

-> Main Class:

public class PaymentInterfaceApp {
    public static void main(String[] args) {
        IPaymentGateway payment = new PayPal();
        payment.pay(500);
        payment.printReceipt();
    }
}

->Op:Paid ₹500.0 via PayPal
Receipt printed (interface)

Summary with Real-World Metaphor
==============================
Concept 	Real World
Abstract Class	A template for all employees in a company. It defines what every employee has (name, ID) and does (come to work).
Interface	A contract like a "Driver License" – any class that implements it must provide specific capabilities, like drive().

 When to Prefer Abstract Class:
===============================
When classes are closely related.
When you want to provide base logic.
When you want to enforce a common state or behavior.

✅ When to Prefer Interface:
============================
When classes are unrelated but share functionality.
When you want to ensure a contract is followed.
When you need multiple inheritance (Java doesn’t support multiple classes inheritance, but interfaces can help simulate it).
==============================================================================================

Interface & Functional Interface
================================
What is an Interface in Java?
-----------------------------
->An interface is a contract that defines a set of abstract methods (i.e., method declarations without implementations)
-> Any class that implements the interface agrees to provide concrete implementations of those methods.

Syntax:
public interface Vehicle{
void start();
void stop();
}


 Real-time Use Case:
-------------------
->Assume you have multiple vehicle types (Car, Bike, Bus). All of them should start and stop, but each does it differently.
So you create an interface Vehicle that enforces this contract.

public class Car implements Vehicle {
    public void start() {
        System.out.println("Car starting with key ignition");
    }
    public void stop() {
        System.out.println("Car stopping by pressing brake");
    }
}


Purpose of Interfaces:
------------------------
To achieve abstraction.
To support multiple inheritance (a class can implement multiple interfaces).
To define common behavior across different classes.
To support loose coupling (especially in polymorphism, design patterns, etc.).

Functional Interface in Java (since Java 8)
--------------------------------------------

->A Functional Interface is a special type of interface that contains exactly one abstract method. 
->It may have multiple default or static methods, but only one abstract method.
->Syntax using @FunctionalInterface:
@FunctionalInterface
public interface Calculator {
    int operate(int a, int b);
}


->Note: @FunctionalInterface annotation is optional but helps the compiler catch mistakes.

Interface vs Functional Interface
-----------------------------------

Feature	                     Interface                  	Functional Interface
Abstract Methods	Can have one or many	                Exactly one
Java Version	       Available since Java 1.0	              Introduced in Java 8
Lambda Support	           Not required	                      Supports lambda expressions
Use Case	   Used for abstraction, contracts	    Used for lambda, functional programming
Annotation	  No special annotation required	        Uses @FunctionalInterface (optional)


 Why Functional Interfaces Are Useful
---------------------------------------
->Functional interfaces allow cleaner, concise code using lambda expressions and method references, especially in functional programming and APIs like Streams, Collections, etc.

Common Built-in Functional Interfaces (Java 8)
------------------------------------------------

Interface	         Abstract Method Signature	                   Purpose/Use Case
Function<T,R>	            R apply(T t)	              Transforms input to output (e.g., String → Integer)
Consumer<T>	            void accept(T t)	              Performs an action on input (no return)
Supplier<T>	            T get()	                      Supplies data (no input)
Predicate<T>	            boolean test(T t)	              Checks a condition and returns boolean
BiFunction<T,U,R>	    R apply(T t, U u)	              Two inputs → one output
BinaryOperator<T>	    T apply(T t1, T t2)	              Same type inputs and output
UnaryOperator<T>	    T apply(T t)	              Same type input/output, one param
BiPredicate<T,U>	    boolean test(T t, U u)	      Two inputs, returns boolean



A. Function<T, R> – Convert a name to its length
--------------------------------------------------

Function<String,Integer> nameLength = name -> name.length();
System.out.println(nameLength.apply("swapnil")); //op :7

->Explanation:
Function<T, R> means: you give it a T (input) and it returns an R (output).
Here, input is a String ("Swapnil") and output is Integer (7, because "Swapnil" has 7 characters).
.apply() is the method that performs the operation.

->Real-World Use Case:
Suppose you're processing a list of names in a registration form and need to know the length of each name.
This is commonly used in .map() with Java Streams.


 B. Consumer<T> – Print a message
---------------------------------
Consumer<String> greeter =  message -> System.out.println("Hello," + message);
greeter.accept("Java Developer"); op:-Hello, Java Developer

->Explanation:
Consumer<T> takes one input and returns nothing (void).
It is used to perform an action (like logging, printing).
Here, it takes a string and prints it with "Hello, " in front.

->Real-World Use Case:
Logging user activity (e.g., Consumer<String> logger = msg -> log.info(msg);)
Displaying data on the screen
Writing data to files or systems


 C. Supplier<T> – Generate a random number
--------------------------------------------
Supplier<Double> randomValue = () - > Math.random();
System.out.println(randomValue.get());

->Explanation:
Supplier<T> has no input, but it supplies (returns) a value of type T.
Here, it returns a random Double when .get() is called.

->Real-World Use Case:
Generating random OTPs or tokens
Supplying default configurations
Lazy loading values only when needed

D. Predicate<T> – Check if a number is even
--------------------------------------------
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(10)); // true

->Explanation:
Predicate<T> takes one input and returns a boolean.
It's used to check conditions.
Here, it checks if a number is even.

->Real-World Use Case:
Filtering records in a list (e.g., all employees with salary > 50k)
Validating form fields
Conditional logic in streams (filter())

E. BiFunction<T, U, R> – Sum of two numbers
-------------------------------------------
BiFunction<Integer, Integer, Integer> sum = (a, b) -> a + b;
System.out.println(sum.apply(10, 20)); // Output: 30

->Explanation:
BiFunction<T, U, R> takes two inputs and returns one output.
Here: inputs are both Integer (10 and 20), output is also Integer (30).
.apply(a, b) runs the logic.

->Real-World Use Case:
Calculating price with quantity (price * quantity)
Merging values (e.g., first name + last name)
Used in data transformation functions

 F. BinaryOperator<T> – Multiply two numbers
--------------------------------------------
BinaryOperator<Integer> multiply = (a, b) -> a * b;
System.out.println(multiply.apply(5, 6)); // Output: 30

->Explanation:
BinaryOperator<T> is like BiFunction<T, T, T>.
It takes two values of the same type and returns same type.
Here: input 5 and 6 → output 30.

->Real-World Use Case:
Arithmetic operations (multiply, divide, add)
Reducing a list to a single value (e.g., total amount)
Used in .reduce() operations in streams

G. UnaryOperator<T> – Square a number
------------------------------------
UnaryOperator<Integer> square = n -> n * n;
System.out.println(square.apply(4)); // Output: 16

->Explanation:
UnaryOperator<T> is a special Function<T, T> — takes one input and returns the same type.
Here: input = 4 → output = 4×4 = 16.

->Real-World Use Case:
Apply discount, square, cube, increment, etc.
Transform values while looping through a list
Use in .map() to apply transformation to each item

H. BiPredicate<T,U>
----------------------
BiPredicate<String, String> isLoginValid = (username, password) ->
        username.equals("admin") && password.equals("12345");

System.out.println(isLoginValid.test("admin", "12345"));  // true
System.out.println(isLoginValid.test("user", "12345"));   // false


->Definition:
A BiPredicate is a functional interface in Java that:
Takes two input arguments (of any types T and U)
Returns a boolean result (true or false)
It is used when you want to check a condition involving two inputs.

->Method signature:boolean test(T t, U u);
T and U are the types of the two inputs.
test() method contains the condition to be checked.

-> What’s Happening Here in program?
isLoginValid takes 2 String inputs (username, password).
It checks if both match "admin" and "12345".
It returns true or false based on the condition

->Real-Time Use Cases of BiPredicate:
Use Case	                   Explanation
✅ Authentication	       Check if a username and password match
✅ Validation	               Validate if two input values meet a condition (e.g., age and ID type)
✅ Filtering with Streams	Filter a list of objects based on two parameters
✅ Custom Comparisons	       Compare two objects for a specific rule


->Check if the sum of two numbers is even

BiPredicate<Integer, Integer> isSumEven = (a, b) -> (a + b) % 2 == 0;
System.out.println(isSumEven.test(10, 4));  // true
System.out.println(isSumEven.test(5, 2));   // false


-> Check if a string contains another string (case-insensitive)

BiPredicate<String, String> containsIgnoreCase = (main, sub) ->
        main.toLowerCase().contains(sub.toLowerCase());

System.out.println(containsIgnoreCase.test("Java Programming", "java")); // true
System.out.println(containsIgnoreCase.test("Backend", "end"));           // true


 Custom Functional Interface with Lambda
-------------------------------------------
@FunctionalInterface
interface GreetingService {
    void greet(String name);
}

public class Main {
    public static void main(String[] args) {
        GreetingService service = name -> System.out.println("Hello " + name);
        service.greet("Swapnil");
    }
}

->Used for defining custom behaviors in microservices, background jobs, etc.


Real-Time Project Scenario: Java Stream with Predicate & Function
-----------------------------------------------------------------

List<String> names = Arrays.asList("Amit", "Swapnil", "Neha", "Raj");

List<String> filtered = names.stream()
    .filter(name -> name.startsWith("S"))      // Predicate
    .map(String::toUpperCase)                  // Function
    .collect(Collectors.toList());

System.out.println(filtered); // Output: [SWAPNIL]

->Used in:Java 8 Streams,Spring Boot filters,Functional pipelines


Summary
-----------
Concept	                                             Explanation
Interface	                  A contract with method declarations (abstraction, polymorphism)
Functional Interface	          Interface with exactly one abstract method (Java 8+)
Lambda	                          Anonymous implementation of a functional interface
Built-in Interfaces	         Function, Predicate, Consumer, Supplier, BiFunction, etc.
Real-world Uses	                 Event handling, API filters, mapping, validation, data processing

=======================================================================================================================
---------------------------------
peek() method in stream API
---------------------------------

->The **peek()** method in Java Stream API is an intermediate operation that allows you to perform a side-effect (like logging or debugging) without modifying the stream elements.

Stream<T> peek(Consumer<? super T> action)

->It returns a new stream, consisting of the elements of the original stream.
->The action passed to peek() is performed on each element as it passes through, mainly for debugging or logging.
->It does not terminate the stream — you still need a terminal operation like collect(), forEach(), etc.

==========
Use Cases:
==========
->Debug the pipeline of stream operations.
->Log intermediate steps without altering data.
->Track how elements flow through transformations.

Important Notes:
----------------
->peek() is not guaranteed to be executed if there's no terminal operation.
->Do not use it for modifying data — it's intended for observing only.

import java.util.Arrays;
import java.util.List;

public class PeekExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("John", "Jane", "Jack", "Jill");

        List<String> result = names.stream()
            .peek(name -> System.out.println("Original: " + name))  // Debug original
            .filter(name -> name.startsWith("J"))
            .peek(name -> System.out.println("After filter: " + name))  // After filtering
            .map(String::toUpperCase)
            .peek(name -> System.out.println("After map: " + name))  // After mapping
            .toList();  // Terminal operation

        System.out.println("Final Result: " + result);
    }
}

op:-Original: John
After filter: John
After map: JOHN
Original: Jane
After filter: Jane
After map: JANE
Original: Jack
After filter: Jack
After map: JACK
Original: Jill
After filter: Jill
After map: JILL
Final Result: [JOHN, JANE, JACK, JILL]

When NOT to use peek():
========================
->To change the element's data (use map() instead).
->For business logic. It's meant only for inspection/logging.


Summary
--------
Feature	              Description
Type 	             Intermediate operation
Purpose	             Side-effects like logging or debugging
Input	             Consumer<T>
Returns	             Stream with same elements
Needs Terminal Op    Yes
==========================================================================================================================
Use of @Primary & @Qualifier annotations
-------------------------------------------

->In Spring, when you have multiple beans of the same type (interface or class), and you autowire that type, Spring doesn’t know which bean to inject. 
This causes a NoUniqueBeanDefinitionException
->To resolve this conflict, Spring provides:

@Primary – To mark one bean as default.
@Qualifier – To specify exactly which bean you want when autowiring.

1. @Primary Annotation
======================
->Purpose:When multiple beans of the same type are available, @Primary tells Spring to prefer this bean by default, unless a specific @Qualifier is used.

syntax:-
@Primary
@Bean
public MyService myPrimaryService() {
    return new MyServiceImpl1();
}


->Example with @Primary
Let’s say you have an interface:

public interface PaymentService {
    void pay();
}


->And two implementations:

@Component
public class CreditCardPaymentService implements PaymentService {
    public void pay() {
        System.out.println("Paid using Credit Card");
    }
}

@Primary
@Component
public class UpiPaymentService implements PaymentService {
    public void pay() {
        System.out.println("Paid using UPI");
    }
}


->Now if you do:
@Autowired
private PaymentService paymentService;

->Spring will inject UpiPaymentService because it is marked with @Primary.


2. @Qualifier Annotation
========================
->Purpose:@Qualifier is used when you want to explicitly specify which bean to inject when multiple candidates are available

->Syntax:
@Autowired
@Qualifier("beanName")
private PaymentService paymentService;


->Example with @Qualifier
Same interface and implementations:

@Component("creditCardService")
public class CreditCardPaymentService implements PaymentService {
    public void pay() {
        System.out.println("Paid using Credit Card");
    }
}

@Component("upiService")
public class UpiPaymentService implements PaymentService {
    public void pay() {
        System.out.println("Paid using UPI");
    }
}

->Inject specific one like this:

@Autowired
@Qualifier("creditCardService")
private PaymentService paymentService;


->This will inject CreditCardPaymentService.

When to use what?
===================
Scenario	                                 Use
One preferred default implementation	        @Primary
You need precise control	                @Qualifier("beanName")
Multiple implementations exist	                Use @Qualifier on injection
You want to override default	                Use @Primary on the desired bean


Summary
==========
Annotation	Purpose	Placement
@Primary	Default bean when multiple candidates	On class or method
@Qualifier	Specific bean selection when autowiring	On injection point

Real-time analogy
==================

Imagine you have two payment gateways in your app:RazorPay & Stripe
Spring sees both. Which to inject?
Mark RazorPay as @Primary to make it default.
Or, use @Qualifier("stripe") when you want Stripe specifically.
==========================================================================================================================

How to reduce our Sprinboot startup time 
===========================================
->Startup time is the time it takes for a Spring Boot application to become fully ready to serve requests after you run it.
->This includes:
Loading and creating Spring beans
Starting the embedded web server (Tomcat, Jetty)
Parsing application.yml or application.properties
Running @PostConstruct, CommandLineRunner, etc.
Scanning packages and initializing auto-configurations


Why Startup Time Matters?
===========================
In modern applications (especially cloud, microservices, Kubernetes):
Faster startup helps with auto-scaling (new instances come up quickly)
Improves fault recovery
Speeds up CI/CD deployments
Saves resources in serverless or container environments

1. Enable Lazy Initialization
-----------------------------
->What it does: Creates Spring beans only when needed, not all at startup.
->In application.properties or application.yml:spring.main.lazy-initialization=true
->Benefit: Reduces the number of beans loaded at startup.
->Interview Tip:“With lazy initialization, only the required beans are created at runtime instead of all at startup, which reduces initial load time"

2. Use Only Required Dependencies (JARs)
-------------------------------------------
->Avoid adding unnecessary Spring Boot starters like:
<artifactId>spring-boot-starter-data-jpa</artifactId>
<artifactId>spring-boot-starter-security</artifactId>

->if you’re not using them.Why? Extra dependencies = more beans, more scanning, more startup time.
->Interview Tip:“We should remove unused dependencies to prevent unnecessary auto-configuration and class loading during startup.”

3. Exclude Unused Auto-Configurations
-------------------------------------
->Use exclude in your main class to skip loading certain features:
@SpringBootApplication(exclude = {
  DataSourceAutoConfiguration.class,
  SecurityAutoConfiguration.class
})

->Benefit: Skips scanning and setting up features you don't need.
->Interview Tip:“I use @SpringBootApplication’s exclude attribute to prevent unnecessary Spring Boot modules from being auto-configured.”


4. Avoid Heavy Work in @PostConstruct, CommandLineRunner, etc.
===============================================================
->Don’t put long-running code (e.g., DB queries, file I/O) in these methods.
->Best Practice:Use @EventListener(ApplicationReadyEvent.class) or run in a background thread.
->Interview Tip:“Heavy logic should be executed after the app starts, not during boot. I move such logic to ApplicationReadyEvent.”

5. Use @Profile for Environment-Specific Beans
================================================
->Load only the beans required for the current environment.
@Profile("prod")
@Bean
public DataSource prodDataSource() { ... }

->Benefit: Prevents dev/test beans from being loaded in prod and vice versa
->Interview Tip:“I use @Profile to load environment-specific beans and avoid unnecessary object creation.”

6. Use Spring Boot Actuator's Startup Endpoint (For Analysis)
-------------------------------------------------------------
->Enable startup metrics to analyze slow parts of boot process.
management.endpoint.startup.enabled=true
->Access it at:
http://localhost:8080/actuator/startup
->Benefit: See which beans take the longest to load.
->Interview Tip:“Actuator’s startup endpoint helps me diagnose which beans or configs are slowing down startup.”

7. Use Layered JARs (For Dockerized Apps)
-------------------------------------------
->Layered JARs speed up Docker builds and deployments.
mvn spring-boot:build-image
->Benefit: Docker reuses base layers, improving startup and rebuild time.
->Interview Tip:“Layered JARs reduce Docker image build time and improve container boot performance.”


8. Use Native Image with GraalVM (Advanced)
============================================
->Convert your Spring Boot app into a native executable (not a JAR).
->Command (after setup):mvn -Pnative native:compile
->Startup Time: ~50ms instead of seconds!
->Interview Tip:“For extremely fast boot, I use GraalVM to build native images. It compiles the app ahead-of-time.”

Bonus Tips
----------
->Minimize logging in application.properties:logging.level.root=warn
->Avoid component scanning large packages like com.example, and instead scan only what you need.
@ComponentScan(basePackages = {"com.example.service"})


What You Can Say in the Interview:
-----------------------------------
“Bootstrap time is the time it takes for Spring Boot to fully start. 
In microservices and cloud environments, it's important to keep it low for faster scaling and recovery. 
To reduce it, I use lazy initialization, remove unused dependencies, exclude unnecessary auto-configs, defer heavy startup logic, and use profiles to load only what's needed. 
For deeper analysis, I use the actuator’s startup metrics. 
In containerized apps, I prefer layered JARs, and for extreme performance, native images with GraalVM.”

============================================================================================================================================================================

What happens when springboot application starts
===============================================
->Let’s say we run this simple Spring Boot application:
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}

Now, What Happens When This App Starts?
---------------------------------------
1. JVM Starts the Main Method
-----------------------------
->This is like any Java application — the main() method is the starting point.
SpringApplication.run(MyApp.class, args);
->This triggers Spring Boot to start bootstrapping your application.

2. Creates a SpringApplication Object
---------------------------------------
->Internally, Spring Boot does:SpringApplication app = new SpringApplication(MyApp.class);
->This object is responsible for:
Loading Spring context,Setting environment,Detecting configurations,Starting beans,Managing the lifecycle

3. Detects Application Type (Servlet or Reactive)
---------------------------------------------------
->Spring Boot checks:Is it a web app? & Should it run an embedded server like Tomcat or Netty?
->t finds this by checking the classpath (your JARs/dependencies).
Example:If spring-boot-starter-web is present → run with Tomcat & If spring-boot-starter-webflux is present → run with Netty

4. Loads application.properties or application.yml
-----------------------------------------------------
->Spring Boot loads your configuration file:
server.port=8081
spring.datasource.url=...

->This is handled by:Environment environment = application.getEnvironment();
->So your application can read and use these settings.

5. Starts Application Context
------------------------------
->This is the core of Spring.
->Spring creates the ApplicationContext, which:
Manages the lifecycle of all beans
Handles dependency injection
Applies AOP, Events, Security, etc.
You can think of this like Spring's "engine room".

6. Performs Component Scanning
------------------------------
->Spring scans the packages from your main class:@ComponentScan(basePackages = "com.example")
->It looks for annotations like:@Component @Service @Repository @Controller @RestController @Configuration
->And it registers those classes as Spring beans in the container.

7. Applies Auto-Configuration
---------------------------
->Now comes the magic part:Spring Boot looks at your dependencies and auto-configures things.
->Example:
If you have spring-boot-starter-data-jpa, it configures JPA, EntityManager, etc.
If you have spring-boot-starter-web, it configures Tomcat, DispatcherServlet, etc.
Auto-configurations come from spring.factories files.
 
8. Initializes Embedded Server (if web app)
------------------------------------------
->If your app is web-based, Spring Boot starts Tomcat (or Jetty/Netty) on the default port 8080.
->You’ll see this in logs:Tomcat started on port(s): 8080 (http)
->Now your app is ready to receive requests.

9. Runs Application Runners
--------------------------
->If you have any of the following:CommandLineRunner,ApplicationRunne,r@PostConstruct
->Spring will run those after startup.
@Component
public class StartupRunner implements CommandLineRunner {
    public void run(String... args) {
        System.out.println("App Started!");
    }
}

10. Application is Ready
-----------------------
->You’ll see in the log:Started MyApp in 4.235 seconds (JVM running for 4.556)
->This means Spring Boot:Loaded all beans,Started Tomcat,Is listening for requests

Summary: Spring Boot Startup Flow
================================

Here's the flow in simple bullet points:

JVM runs the main() method
SpringApplication object is created
Determines app type (web/reactive)
Loads application.properties or .yml
Creates ApplicationContext
Scans and registers Spring beans
Applies auto-configuration
Starts embedded web server (Tomcat)
Runs startup logic (CommandLineRunner, etc.)
App is ready to serve requests


->“The JVM runs the main method, which triggers SpringApplication to start the app. 
It loads configs, scans components, applies auto-config, starts the ApplicationContext, and if it's a web app, it boots the embedded server like Tomcat. 
Finally, any CommandLineRunner or PostConstruct logic runs, and the app becomes ready to serve requests.”

==============================================================================================================================================================

Process of creating spring boot project
=========================================

1. Project Initialization
---------------------------
->I usually start by creating a new Spring Boot project using either Spring Initializr or directly via an IDE like IntelliJ IDEA or using spring CLI.

a. Using Spring Initializr UI (Most Common in Industry):
-----------------------------------------------------------
Go to start.spring.io

Select:Project: Maven (or Gradle),Language: JavaSpring Boot: (latest stable version),Group: com.mycompany,Artifact: orderservice,Name: OrderService,Packaging: Jar,Java version: 17 or 21
Dependencies:Spring Web,Spring Boot DevTools,Spring Data JPA,Spring Security (if required),Lombo,Spring Cloud Config / Eureka Discovery Client (for microservices),PostgreSQL or MySQL Driver


b. Using Spring CLI (Optional):
------------------------------
spring init --dependencies=web,data-jpa,postgresql,lombok,devtools \
    --groupId=com.mycompany --artifactId=orderservice \
    orderservice

2. Import the Project into IDE
-------------------------------
->Once generated, I import the project into IntelliJ or Eclipse and let Maven/Gradle resolve all dependencies. 
I also verify the basic folder structure and configuration.

src/
 └── main/
     ├── java/com/mycompany/orderservice
     └── resources
         ├── application.yml or application.properties
         └── static/templates (if web app)


3. Configure application.yml or application.properties
-------------------------------------------------------
->I define basic configurations like server port, datasource, JPA settings, and environment-specific configurations.
server:
  port: 8081

spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/orders
    username: postgres
    password: password
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
  application:
    name: order-service

4. Create the Main Class
-------------------------
->Spring Boot generates the main class with the @SpringBootApplication annotation, which is a meta-annotation combining @Configuration, @EnableAutoConfiguration, and @ComponentScan.

@SpringBootApplication
public class OrderServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(OrderServiceApplication.class, args);
    }
}


5. Define Entity, Repository, Service, Controller Layers
-----------------------------------------------------------
->I follow a layered architecture and clean separation of concerns
Example: Order Microservice
----------------------------
a. Entity:
----------
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String product;
    private int quantity;
    private double price;
}

b. Repository:
--------------
public interface OrderRepository extends JpaRepository<Order, Long> {
}


c. Service:
------------
@Service
public class OrderService {
    @Autowired
    private OrderRepository repo;

    public Order saveOrder(Order order) {
        return repo.save(order);
    }

    public List<Order> getAllOrders() {
        return repo.findAll();
    }
}

d. Controller:
--------------
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    @Autowired
    private OrderService service;

    @PostMapping
    public ResponseEntity<Order> create(@RequestBody Order order) {
        return ResponseEntity.ok(service.saveOrder(order));
    }

    @GetMapping
    public List<Order> list() {
        return service.getAllOrders();
    }
}

6. Use DevTools for Hot Reload (Optional but Common)
------------------------------------------------------
<!-- Maven -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
    <scope>runtime</scope>
</dependency>

7. Testing the API
-------------------
->I use Postman or Swagger (via SpringDoc) to test the endpoints.
->Add SpringDoc Swagger Dependency:
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-ui</artifactId>
    <version>1.6.15</version>
</dependency>

->Swagger UI available at: http://localhost:8081/swagger-ui.html

8. Dockerize the Spring Boot App (Microservices Best Practice)
---------------------------------------------------------------
Dockerfile:
-------------

FROM openjdk:17-jdk-alpine
VOLUME /tmp
ARG JAR_FILE=target/orderservice.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]


Build and Run:
--------------
mvn clean package
docker build -t orderservice .
docker run -p 8081:8081 orderservice

9. Integrate with AWS (Optional, Based on Interview Focus)
-----------------------------------------------------------
->I’ve also deployed Spring Boot apps on AWS using:Elastic Beanstalk,ECS with Fargate,EC2 + Nginx,API Gateway + Lambda (for serverless needs)

->Also familiar with:S3 for file storage,RDS for DB,Parameter Store/Secrets Manager for secure config


Summary (End Your Answer Like This)
======================================

->So overall, I start with Spring Initializr, structure the project with layered architecture, use best practices like Swagger, Dockerization, and profile-based configs. 
For microservices, I integrate service discovery (like Eureka), centralized config, and monitoring (e.g., Actuator, Prometheus + Grafana).


Tips for Bonus Points in Interview
-----------------------------------
Mention application-{profile}.yml and @Profile for environments
Talk about CI/CD using GitHub Actions or Jenkins
Bring in circuit breaker (e.g., Resilience4j)
Mention observability using Spring Boot Actuator & Micrometer
Use DTOs for API responses (avoid exposing entities directly)
Validate inputs using @Valid, @NotNull, etc.

========================================================================================================================================================================================

Create One Springboot Project to call Rest API
=================================================
Project Overview
----------------
->Let’s create a Spring Boot app named PostConsumerService, which1. 
->Create Project Using Spring Initializr
--------------------------------------
Dependencies:Spring Web,Spring Boot DevTools,Lombok,Spring Boot Starter WebFlux (for WebClient)

Suggested structure:
com.example.postconsumer
├── controller
├── service
├── client
└── model


2. application.yml Configuration
---------------------------------
server:
  port: 8080

external:
  api:
    base-url: https://jsonplaceholder.typicode.com

3. Model Class (Post.java)
--------------------------
model/Post.java
---------------
package com.example.postconsumer.model;
import lombok.Data;
@Data
public class Post {
    private Long userId;
    private Long id;
    private String title;
    private String body;
}

4. Client Layer (API Call Using WebClient)
-----------------------------------------
client/PostApiClient.java
--------------------------
package com.example.postconsumer.client;

import com.example.postconsumer.model.Post;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

@Component
@RequiredArgsConstructor
public class PostApiClient {

    private final WebClient.Builder webClientBuilder;

    @Value("${external.api.base-url}")
    private String baseUrl;

    public Mono<Post> getPostById(Long id) {
        return webClientBuilder.build()
                .get()
                .uri(baseUrl + "/posts/{id}", id)
                .retrieve()
                .bodyToMono(Post.class);
    }
}

Bean config (if needed):
-------------------------
@Bean
public WebClient.Builder webClientBuilder() {
    return WebClient.builder();
}

5. Service Layer
----------------
service/PostService.java
-------------------------
package com.example.postconsumer.service;

import com.example.postconsumer.client.PostApiClient;
import com.example.postconsumer.model.Post;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class PostService {

    private final PostApiClient client;

    public Post getPost(Long id) {
        return client.getPostById(id).block();  // blocking here for simplicity in a non-reactive context
    }
}

6. Controller Layer
--------------------
📁 controller/PostController.java
----------------------------------
package com.example.postconsumer.controller;

import com.example.postconsumer.model.Post;
import com.example.postconsumer.service.PostService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/posts")
@RequiredArgsConstructor
public class PostController {

    private final PostService postService;

    @GetMapping("/{id}")
    public ResponseEntity<Post> getPostById(@PathVariable Long id) {
        Post post = postService.getPost(id);
        return ResponseEntity.ok(post);
    }
}

7. Main Class
-------------
📁 PostConsumerServiceApplication.java
---------------------------------------

@SpringBootApplication
public class PostConsumerServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(PostConsumerServiceApplication.class, args);
    }
}

8. Test the API
---------------
->Run the application and hit:

GET http://localhost:8080/api/posts/1

->t should return:
{
  "userId": 1,
  "id": 1,
  "title": "sunt aut facere repellat provident occaecati...",
  "body": "quia et suscipit suscipit recusandae..."
}

Explain Why You Used WebClient
-------------------------------
->chose WebClient instead of RestTemplate because it's the preferred non-blocking client from Spring 5 onwards. 
While I’m using .block() here for simplicity in a traditional layered approach, in reactive applications, I’d keep the flow fully non-blocking with Mono or Flux.



Error Handling & Timeouts (Advanced Answer Add-on)
--------------------------------------------------
->You can also explain:I usually configure timeouts and global error handling using exchangeStrategies() and onStatus() in WebClient or use Spring’s @ControllerAdvice for global exception management.

Bonus: Dependency in pom.xml
-----------------------------
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>


Final Summary for Interview
----------------------------
So, to summarize, I created a Spring Boot project that exposes a REST endpoint. Internally, it uses WebClient to call an external REST API, maps the response to a model, and returns it to the caller.
I followed a clean layered architecture, handled dependencies using Spring Boot starters, and used modern WebClient for API interaction.

->if you want to implement the same functionality using RestTemplate instead of WebClient, it’s very straightforward.
->RestTemplate is the traditional synchronous HTTP client provided by Spring. It’s simple and perfect for non-reactive, blocking use cases.
Though deprecated in newer versions in favor of WebClient, it’s still valid and widely used in enterprise apps.	

1. Add RestTemplate Bean
----------------------
->PostConsumerServiceApplication.java or a new @Configuration class
import org.springframework.context.annotation.Bean;
import org.springframework.web.client.RestTemplate;

@SpringBootApplication
public class PostConsumerServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(PostConsumerServiceApplication.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

2. Modify the Client Layer
--------------------------
client/PostApiClient.java

package com.example.postconsumer.client;

import com.example.postconsumer.model.Post;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component
@RequiredArgsConstructor
public class PostApiClient {

    private final RestTemplate restTemplate;

    @Value("${external.api.base-url}")
    private String baseUrl;

    public Post getPostById(Long id) {
        String url = baseUrl + "/posts/" + id;
        return restTemplate.getForObject(url, Post.class);
    }
}

->no changes in servive layer,controller layer and app.properties & No need for spring-boot-starter-webflux

